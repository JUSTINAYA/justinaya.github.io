<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023美赛经验分享</title>
    <url>/2023/02/23/2023/2023%E7%BE%8E%E8%B5%9B%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<blockquote>
<p>2023美赛参赛有感</p>
</blockquote>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>2023年美赛已经告一段落，我也在这一次的比赛中收获良多，因此，我也在此将自己本次参赛的一些心得进行分享，希望能在一定程度上帮助有需要的人。</p>
<h1 id="赛前">赛前</h1>
<h2 id="组队">组队</h2>
<p>我在很早（大概是大一下学期的暑假）就有了参加美赛的想法，当时就在表白墙找了队友，准备在暑假里学一学的，但出于一些原因，最后没能坚持下来。到快美赛报名的时候，我的两个室友已经组好了队，缺一个论文手，我想我也有点word使用功底，就和他们一起组了队。舍友或者朋友之间组队有一个好处，就是大家之间基本上知根知底的，都知道对方是什么样的人，会比较靠谱，而这样的坏处就是专业方向基本一致，像我们三个都是计软院的，我是数据科学与大数据技术的，两个舍友是软件工程的。其实我认为不需要太过追求专业多样化，比如数学专业的建模手，计算机专业的编程手，文科专业的论文手这样的，首先不一定专业对口专业性就强，其次互相之间如果不是很熟悉的话容易出事，造成两人建模甚至一人建模这样子。我认为<code>靠谱</code>还是找队友的第一标准。</p>
<h2 id="准备">准备</h2>
<p>在赛前最好还是了解下参赛流程还有比赛需要的知识，可以在网上找找获奖大佬的经验分享或者问问学校里参赛过的同学，像我就是向院里获F奖的学长请教了，他所分享的经验也让我收获颇深，还给我发了一些论文和模版啥的，我也在比赛的时候用上了；还有就是看了我们学校获O奖的学长宋浩然在B站作出的分享，多多少少也有帮助吧。</p>
<h3 id="关于编程">关于编程</h3>
<p>编程手至少需要会<code>Matlab</code>，像我们组的编程手就是用<code>Matlab</code>还有<code>SPSS</code>，如果是画图，我还推荐<code>Python</code>和<code>Jupyter Notebook</code>，Jupyter
Notebook本质上也是Python，Python有很多第三方库软件包的支持，网上也有很多的教程，可以画出一些“高大上”的图，在机器学习和数据分析这两方面也有着得天独厚的优势，在这里我分享几个常用的库：</p>
<blockquote>
<ol type="1">
<li>numpy</li>
<li>matplotlib</li>
<li>pandas</li>
</ol>
</blockquote>
<p>这些库不管是用来做数据分析或者画图都很有用，网上也有很多的教程，在这里就不过多赘述了。</p>
<h3 id="关于建模">关于建模</h3>
<p>建模手主要还是得了解各种<code>模型</code>：</p>
<blockquote>
<p>优化模型</p>
<p>预测模型</p>
<p>分类模型</p>
<p>评价模型</p>
<p>······</p>
</blockquote>
<p>我们的建模手是跟着B站的<code>数学建模清风</code>在学，感觉还挺不错的，经典的模型一定要懂，也要多看看O奖论文，其实很多O奖论文的模型看似高大上，其实也只是高级套皮而已，我们只需要在比赛的时候现学现卖就行。</p>
<h3 id="关于论文">关于论文</h3>
<p>论文写作工具可以用<code>Word</code>，也有不少人推荐使用<code>Latex</code>，本次比赛里我使用了Word进行写作，我来讲讲这两个工具各自的优点：</p>
<p><strong>Word</strong></p>
<blockquote>
<ol type="1">
<li>上手快，所见及所得</li>
<li>功能强大，基本上你的要求它都可以满足</li>
<li>教程十分多，不懂的上网都能查得到</li>
</ol>
</blockquote>
<p><strong>Latex</strong></p>
<blockquote>
<ol type="1">
<li>不需要自己排版</li>
<li>排版美观</li>
</ol>
</blockquote>
<p>这两个工具可以自行选择，Latex麻烦的一点就是需要会编程语言，学习成本大，不能可视化。不过现在也有能让Latex可视化的网站，感觉还挺好。这次比赛我用的是Word，因为有模版，用起来还是很顺手的。</p>
<p>英文写作的话我们这次完全使用的<code>有道翻译</code>进行机翻，正确率还是很高的，不过翻完还是得自己看一下表达的意思对不对。其余的话我也推荐<code>谷歌翻译</code>，<code>DeepL</code>，翻译文献的话用<code>知云文献翻译</code>，当然还有一个人工智能，懂得都懂，这里不多说。</p>
<h1 id="赛中">赛中</h1>
<p>经历这次比赛，我觉得<code>时间分配</code>还是十分重要的，这次我们选择了E题，我想也是最多人选择的一题。但在做第一问的时候建模手卡住了，导致论文手也在坐牢，做出第一问已经是比赛的第三天了，导致后面的流程就很紧张，还好最后是顺利完成了。</p>
<p>关于比赛中网上一些提供思路的或者卖思路的，我觉得看看就好，他们弄的或许看上去做的很对，但也有可能有致命漏洞，自己参加的比赛终究还是靠自己。</p>
<p>这次最让我们感到坐牢的可能还是数据的查找，国内的网站几乎不会有特别符合题目需求的数据，这时候就需要翻墙到外网看看，墙外的世界还是很明朗的</p>
<p>可能队友会在一些问题上产生分歧，就像这次比赛时我们组员也对美国的GDP和中国的GDP不能直接换算进行了争吵，我的评价是最好还是能控制情绪，用愉快的氛围进行比赛，弄的太紧张了也不好，必要的时候做出一些退步。</p>
<h1 id="总结">总结</h1>
<p>这次比赛也算是我大学生涯中参加的第一次比较重大的比赛，总的来说还是很有收获的，两个队友也挺靠谱的，是一段珍贵的经历。</p>
]]></content>
      <categories>
        <category>学科</category>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>美赛</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言：驾驶员理论课程模拟考试与学习系统</title>
    <url>/2023/02/03/2023/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E9%A9%BE%E9%A9%B6%E5%91%98%E7%90%86%E8%AE%BA%E8%AF%BE%E7%A8%8B%E6%A8%A1%E6%8B%9F%E8%80%83%E8%AF%95%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>程序设计道路上的一点成果</p>
</blockquote>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>这是大一下学期程序设计课程的内容，很好地锻炼了我的编程能力，放在这里以供学习。</p>
<h1 id="一课题内容和要求">一、课题内容和要求</h1>
<p>驾驶员理论课程模拟考试与学习系统是在Dev
C++编译环境下以C语言为编程语言编译完成的，为实现驾驶员科目一自主学习，查询知识和进行模拟考试的系统。同时为了方便驾校管理，加入了管理员模块，方便管理员对题库进行修改和编辑，同时，管理员可以为驾校员工添加新的管理员账户，普通用户可在注册后进入系统可进行自主训练，同时能在查看所有习题进行备考和进行错题重做。</p>
<h2 id="课题基本要求">课题基本要求：</h2>
<ul>
<li>提供管理员和用户菜单选项，分别进入不同权限界面；</li>
<li>进入管理员界面需要密码验证，管理员界面负责试题库的管理（修改、查询、删除、增加）以及考试成绩的统计等；</li>
<li>进入用户界面需要输入用户
ID，界面菜单选项具有错题、学习和测验等功能；</li>
<li>用文件保存试题库并可随时增加试题到试题库中；</li>
<li>用户可实现输入自己的答案，系统可根据用户答案与标准答案的对比实现判卷并给出成绩。</li>
</ul>
<h2 id="课题选做要求">课题选做要求：</h2>
<ul>
<li>引进错题系统，可以进行错题重做。</li>
<li>用户可查看所有题库并进行学习。</li>
<li>用户、管理员ID均相对独立，不可重复，减少管理困难。</li>
<li>拥有固定路径的资源库，方便后期对题库等内容进行优化和大面积的软件更新。</li>
</ul>
<h2 id="创新功能与特性">创新功能与特性：</h2>
<ul>
<li>用户每作答一题都会实时判断并给出实时分数，模拟真实考试场景。</li>
<li>管理员可以添加新的管理员。</li>
<li>参考微软等大型公司软件，界面在优化后更清晰整洁，全新的问候与提示语拉近用户距离感，提高用户使用体验。</li>
</ul>
<h1 id="二需求分析">二、需求分析</h1>
<ul>
<li>提供可操作的主菜单：输出菜单，用于显示以从文件中加载的总客户信息和若干个可选的功能选项。根据客户输入的选项来运行不同的功能，运行不同的函数。</li>
<li>用户主菜单和分菜单：用户主菜单提供注册和登录两个功能，适用于拥有和未拥有账号的用户进行相关操作。用户分菜单是用户主要功能菜单，负责提供用户所需的模拟测试，错题学习，知识学习功能的引导并实现相应跳转。</li>
<li>管理员主菜单，分菜单以及题库菜单：管理员主菜单适用于管理员登录，仅在资源库文本文件
admin.txt
中存储的管理员才可以进行登录。管理员分菜单为管理员提供给相应的功能，包括对成绩进行查看，添加新管理员，以及进入题库系统。题库菜单是题库系统的专用菜单，仅管理员才可以访问，它提供了对题目进行删除，增加，编辑等功能。</li>
</ul>
<h1 id="三概要设计"><strong>三、概要设计</strong></h1>
<p>主要存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Admin</span>               //管理员信息存储</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="type">char</span> ID[<span class="number">20</span>];</span><br><span class="line">       <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">       <span class="type">char</span> password[<span class="number">20</span>];</span><br><span class="line">&#125;Admin;</span><br><span class="line">Admin admin[N];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">User</span>                   //用户信息存储</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">       <span class="title">char</span> <span class="title">ID</span>[20];</span></span><br><span class="line">       <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">       <span class="type">char</span> password[<span class="number">20</span>];</span><br><span class="line">&#125;User;</span><br><span class="line">User user[N];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">a</span>               //试题的结构体</span></span><br><span class="line"><span class="class">&#123;</span>         </span><br><span class="line">       <span class="type">char</span> text[M][N];       <span class="comment">//存放试题</span></span><br><span class="line">       <span class="type">char</span> answer[M];       <span class="comment">//存放答案</span></span><br><span class="line">&#125; text_answer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">userscore</span>          //用户成绩的结构体</span></span><br><span class="line"><span class="class">&#123;</span>               </span><br><span class="line">       <span class="type">int</span> userid;                         <span class="comment">//存放用户ID</span></span><br><span class="line">       <span class="type">char</span> username[<span class="number">20</span>];           <span class="comment">//存放用户名</span></span><br><span class="line">       <span class="type">int</span> score;              <span class="comment">//存放用户成绩</span></span><br><span class="line">       <span class="type">int</span> mistakes[M];</span><br><span class="line">&#125; SCORE;</span><br><span class="line">SCORE scores;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">usermis</span>            //用户成绩的结构体</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">       <span class="type">int</span> userid;                         <span class="comment">//存放用户ID</span></span><br><span class="line">       <span class="type">char</span> username[<span class="number">20</span>];           <span class="comment">//存放用户名</span></span><br><span class="line">       <span class="type">int</span> mistakes[M];               <span class="comment">//存放用户错题题号</span></span><br><span class="line">&#125; MISTAKE;</span><br><span class="line">MISTAKE MIS;</span><br><span class="line"> </span><br><span class="line"><span class="number">2.</span>主要函数概要</span><br><span class="line"><span class="comment">//系统菜单部分</span></span><br><span class="line">voidMainM();              <span class="comment">//系统总菜单</span></span><br><span class="line"><span class="comment">//用户菜单部分</span></span><br><span class="line">voidUserSM();             <span class="comment">//用户主菜单(注册和登录)</span></span><br><span class="line">voidUserM();              <span class="comment">//用户菜单（知识学习，测验，错题查看，错题重做）</span></span><br><span class="line"><span class="comment">//管理员菜单部分</span></span><br><span class="line">voidAdminSM();           <span class="comment">//管理员总菜单（登录，添加管理员）</span></span><br><span class="line">voidAdminM();            <span class="comment">//管理员分菜单（题库，成绩管理）</span></span><br><span class="line">voidExerM();              <span class="comment">//题库管理菜单（包含增加，删减，编辑）</span></span><br><span class="line"><span class="comment">//用户函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">login</span><span class="params">()</span>;                           <span class="comment">//用户登录（ID 密码）、</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">regist</span><span class="params">()</span>;                         <span class="comment">//用户注册</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">product_random</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> a[])</span>;       <span class="comment">//题目随机生成</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> pja)</span>;                      <span class="comment">//考试模块函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writescore</span><span class="params">(SCORE scores)</span>;          <span class="comment">//分数写入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writemis</span><span class="params">(SCORE scores,<span class="type">int</span> n)</span>;       <span class="comment">//错题写入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Getmis</span><span class="params">(FILE *fp1,<span class="type">int</span> a[])</span>;            <span class="comment">//错题文件读取</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">moveToNextLine</span><span class="params">(FILE *fp)</span>;          <span class="comment">//文件内容扫描</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Getmistakes</span><span class="params">(MISTAKE MIS)</span>;       <span class="comment">//错题信息获取</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mistest</span><span class="params">(<span class="type">int</span> n,MISTAKE MIS)</span>;       <span class="comment">//错题重做模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">studytest</span><span class="params">()</span>;                       <span class="comment">//学习系统</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">savefile</span><span class="params">()</span>;                        <span class="comment">//用户信息写入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readfile</span><span class="params">()</span>;                        <span class="comment">//用户信息读取</span></span><br><span class="line"><span class="comment">//管理员函数</span></span><br><span class="line">voidshowscore();                      <span class="comment">//分数查看</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addexe</span><span class="params">()</span>;                         <span class="comment">//题目增加</span></span><br><span class="line">voidadminregist();                     <span class="comment">//添加管理员</span></span><br><span class="line">voidadminsavefile();                   <span class="comment">//管理员信息写入</span></span><br><span class="line">voidadminreadfile();                   <span class="comment">//管理员信息读取</span></span><br><span class="line">voidadminlogin();                     <span class="comment">//管理员登录</span></span><br></pre></td></tr></table></figure>
<h1 id="四源程序代码">四、源程序代码</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//maincontrol.c中的代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    MainM();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//user.c中的代码</span></span><br><span class="line"><span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> passwd[<span class="number">20</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> pja)</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag,n=<span class="number">0</span>,m;</span><br><span class="line">    text_answer a;</span><br><span class="line">    <span class="type">char</span> ch1,ans;</span><br><span class="line">    <span class="type">char</span> choice2;</span><br><span class="line">    FILE *fp,*fp1;</span><br><span class="line">    <span class="type">int</span> random[<span class="number">560</span>];</span><br><span class="line">    <span class="type">int</span> mis=<span class="number">0</span>,count=<span class="number">1</span>,right=<span class="number">0</span>,score=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fp1=fopen(<span class="string">&quot;C:\\驾校系统资源库\\text.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line"> &#123; <span class="comment">//判断文件是否打开成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;嗯...试题库文件打开失败，请尝试联系管理员\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>((ch1=fgetc(fp1))!=EOF) </span><br><span class="line">&#123;                                       <span class="comment">//把题目放到数组中</span></span><br><span class="line">            <span class="keyword">if</span>(ch1==<span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch1 &lt;= <span class="number">0</span> || (ch1 &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;9&#x27;</span>) || (ch1 &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;Z&#x27;</span>) || ch1 == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="comment">//把题目放到数组中，题目里的汉字在计算机存的码值小于0</span></span><br><span class="line">            &#123;</span><br><span class="line">                a.text[i][j++]=ch1;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch1&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;ch1&lt;=<span class="string">&#x27;z&#x27;</span>)       <span class="comment">//把答案存到数组中</span></span><br><span class="line">                a.answer[k++]=ch1;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp1);                         <span class="comment">//关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    i=<span class="number">560</span>;</span><br><span class="line">    m=<span class="number">100</span>;</span><br><span class="line">    product_random(i,random);                    <span class="comment">//将随机数放到数组中</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        flag=random[n++];                        <span class="comment">//随机抽题</span></span><br><span class="line">        <span class="keyword">if</span>((flag%<span class="number">5</span>)!=<span class="number">0</span>)。     <span class="comment">//判断随机数是否为5的倍数（题目的行号为5的倍数）</span></span><br><span class="line">            m++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">Reanswer:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d.&quot;</span>,count);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag+<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                        <span class="comment">//输出题目和选项</span></span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag+<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;                                               E.退出考试&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag+<span class="number">3</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag+<span class="number">4</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你选择：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ans);</span><br><span class="line">            <span class="keyword">if</span> (ans!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;ans!=<span class="string">&#x27;B&#x27;</span>&amp;&amp;ans!=<span class="string">&#x27;C&#x27;</span>&amp;&amp;ans!=<span class="string">&#x27;D&#x27;</span>&amp;&amp;ans!=<span class="string">&#x27;E&#x27;</span>) </span><br><span class="line">&#123;                                                     <span class="comment">//判断输入的选项</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;你的选择无效，请重新作答\n&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">goto</span> Reanswer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.answer[flag/<span class="number">5</span>]==ans+<span class="number">32</span>) &#123;                 <span class="comment">//判断答案</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n选择正确\n\n&quot;</span>);</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ans==<span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">Rechoose:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;是否确认退出考试？\n\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;A.是              B.否\n\n&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;choice2);</span><br><span class="line">                <span class="keyword">if</span> (choice2!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;choice2!=<span class="string">&#x27;B&#x27;</span>) </span><br><span class="line">&#123;                                                     <span class="comment">//判断输入的选项</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;你的选择无效，我们无法进行相应操作，请重新选择\n&quot;</span>);</span><br><span class="line">                    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">                    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">goto</span> Rechoose;&#125;</span><br><span class="line">                <span class="keyword">if</span>(choice2==<span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(choice2==<span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">goto</span>  Reanswer;&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n你的选择错误，正确答案为&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c\n\n&quot;</span>,a.answer[flag/<span class="number">5</span>]<span class="number">-32</span>);</span><br><span class="line">                scores.mistakes[mis++]=flag/<span class="number">5</span>;        <span class="comment">//将错题行数放入数组</span></span><br><span class="line">            &#125;</span><br><span class="line">            score=<span class="number">100</span>-mis;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;剩余%d道题目         当前分数%d分\n\n&quot;</span>,<span class="number">100</span>-count,score);</span><br><span class="line"><span class="comment">//输出剩余题目和当前分数</span></span><br><span class="line">            count++;</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(--m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的考试已结束，您的总分为%d分\n&quot;</span>,right);</span><br><span class="line">    scores.score=right;</span><br><span class="line">    scores.userid=((<span class="type">int</span>)user[pja].ID[<span class="number">0</span>]<span class="number">-48</span>)*<span class="number">10000</span>+((<span class="type">int</span>)user[pja].ID[<span class="number">1</span>]<span class="number">-48</span>)*<span class="number">1000</span>+((<span class="type">int</span>)user[pja].ID[<span class="number">2</span>]<span class="number">-48</span>)*<span class="number">100</span>+((<span class="type">int</span>)user[pja].ID[<span class="number">3</span>]<span class="number">-48</span>)*<span class="number">10</span>+((<span class="type">int</span>)user[pja].ID[<span class="number">4</span>]<span class="number">-48</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(scores.username,user[pja].name);</span><br><span class="line">    writescore(scores);</span><br><span class="line">    writemis(scores,mis);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的错题已经记录，你可以进入错题系统查看\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;即将为你返回菜单界面\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    UserM();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">product_random</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> a[])</span> </span><br><span class="line">&#123;                                                      <span class="comment">//产生随机数并放进数组</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">        temp = rand() % x;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp == *(a + j)) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                *(a + i) = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">writescore</span><span class="params">(SCORE scores)</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;C:\\驾校系统资源库\\userscore.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>))==<span class="literal">NULL</span>) </span><br><span class="line">&#123;                                                    <span class="comment">//判断文件是否打开成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;很抱歉，打开成绩记录文件失败，请尝试创建相关文件以继续使用\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d|%s@%d&quot;</span>,                           <span class="comment">//将用户信息和成绩写入文本文件</span></span><br><span class="line">            scores.userid,</span><br><span class="line">            scores.username,</span><br><span class="line">            scores.score);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">writemis</span><span class="params">(SCORE scores,<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;C:\\驾校系统资源库\\mistakes.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>))==<span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;很抱歉，打开错题记录文件失败，请尝试创建相关文件以继续使用\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d|%s@&quot;</span>,                        <span class="comment">//将用户信息和错题题号写入文本文件</span></span><br><span class="line">            scores.userid,</span><br><span class="line">            scores.username);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)  &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d,&quot;</span>,scores.mistakes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">studytest</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>,n=<span class="number">0</span>,m;</span><br><span class="line">    text_answer a;</span><br><span class="line">    <span class="type">char</span> ch1,ans;</span><br><span class="line">    <span class="type">char</span> choice2;</span><br><span class="line">    FILE *fp,*fp1;</span><br><span class="line">    <span class="type">int</span> random[M];</span><br><span class="line">    <span class="type">int</span> mis=<span class="number">0</span>,count=<span class="number">1</span>,right=<span class="number">0</span>,score=<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fp1=fopen(<span class="string">&quot;C:\\驾校系统资源库\\text.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>) </span><br><span class="line">&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;嗯...试题库文件打开失败，请尝试联系管理员&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>((ch1=fgetc(fp1))!=EOF) &#123;            <span class="comment">//把题目放到数组中</span></span><br><span class="line">            <span class="keyword">if</span>(ch1==<span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch1 &lt;= <span class="number">0</span> || (ch1 &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;9&#x27;</span>) || (ch1 &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;Z&#x27;</span>) || ch1 == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="comment">//把题目放到数组中，题目里的汉字在计算机存的码值小于0</span></span><br><span class="line">            &#123;</span><br><span class="line">                a.text[i][j++]=ch1;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch1&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;ch1&lt;=<span class="string">&#x27;z&#x27;</span>)           <span class="comment">//把答案存到数组中</span></span><br><span class="line">                a.answer[k++]=ch1;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp1);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">Reanswer:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d.&quot;</span>,count);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag+<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                                     <span class="comment">//输出题目和选项</span></span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag+<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;                                               E.退出学习&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag+<span class="number">3</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag+<span class="number">4</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;答案为：&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\n\n&quot;</span>,a.answer[flag/<span class="number">5</span>]<span class="number">-32</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;A.上一题                     B.下一题\n\n&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ans);</span><br><span class="line">            <span class="keyword">if</span> (ans!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;ans!=<span class="string">&#x27;B&#x27;</span>&amp;&amp;ans!=<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line"> &#123;                                                         <span class="comment">//判断输入的选项</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;你的选择无效,请重新选择。\n&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;pause&quot;</span>); </span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">goto</span> Reanswer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans==<span class="string">&#x27;A&#x27;</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">                &#123;<span class="built_in">printf</span>(<span class="string">&quot;注意，这已经是第一题\n&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">goto</span> Reanswer;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;flag-=<span class="number">5</span>;</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ans==<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            &#123;<span class="keyword">if</span>(flag==(k<span class="number">-1</span>)*<span class="number">5</span>)</span><br><span class="line">            &#123;<span class="built_in">printf</span>(<span class="string">&quot;注意，已经是最后一题\n&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="keyword">goto</span> Reanswer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;flag+=<span class="number">5</span>;</span><br><span class="line">            count++;</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(ans==<span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">Rechoose:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;是否确认退出学习？\n\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;A.是              B.否\n\n&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;choice2);</span><br><span class="line">                <span class="keyword">if</span> (choice2!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;choice2!=<span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;你的选择无效，请重新选择\n&quot;</span>);</span><br><span class="line">                    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">                    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">goto</span> Rechoose;&#125;</span><br><span class="line">                <span class="keyword">if</span>(choice2==<span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;知识学习已结束。\n&quot;</span>);</span><br><span class="line">                    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">                    system(<span class="string">&quot;cls&quot;</span>); </span><br><span class="line">                    UserM();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(choice2==<span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                     system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">goto</span>  Reanswer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n选择错误，正确答案为&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c\n\n&quot;</span>,a.answer[flag/<span class="number">5</span>]<span class="number">-32</span>);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            flag+=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">regist</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,t;</span><br><span class="line">    <span class="type">int</span> reg= <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> key[<span class="number">20</span>]; </span><br><span class="line">    <span class="type">char</span> account[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> password[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      ************************* 现在，让我们开始注册你的账户 *************************\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      只需要几步简单的操作，你就可以开始使用我们的系统了！请按如下引导操作。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      请注意：你注册的ID必须为5位数字\n&quot;</span>);</span><br><span class="line">a:  <span class="built_in">printf</span>(<span class="string">&quot;      请输入ID：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, account);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strspn</span>(account, <span class="string">&quot;0123456789&quot;</span>) != <span class="built_in">strlen</span>(account))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      ★你输入的ID无效，请重新输入\n\a&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> a; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(account)!=<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      ★你输入的ID长度不合规，请重新输入：\n\a&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> a;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; number; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(user[i].ID, account) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;      ★这个账号已链接到其他账户，请重新输入\n\a&quot;</span>);    </span><br><span class="line">            <span class="keyword">goto</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      请设置你的密码，请注意，您的密码仅限6位：  \n&quot;</span>);</span><br><span class="line">b:    <span class="built_in">printf</span>(<span class="string">&quot;      请输入密码：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, password);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(password)!=<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;      ★你输入的密码长度不合规，请重新输入：\n\a&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> b;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;      请再次输入您的密码:  &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;key);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(key,password) == <span class="number">0</span>) </span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       两次输入的密码不一致，请重新输入 :) \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(t == <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (reg) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(user[number].ID, account);</span><br><span class="line">        <span class="built_in">strcpy</span>(user[number].password, password);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;      请输入你的用户名: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,user[number].name);</span><br><span class="line">        number++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;      搞定！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;      你的账户已激活，现在可以开始使用你的系统了。\n&quot;</span>) ;</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    UserSM();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">login</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">log</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> account[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> password[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n       ************************* 如果你拥有我们的账户，请登录 *************************\n\n&quot;</span>);</span><br><span class="line">   c: <span class="built_in">printf</span>(<span class="string">&quot;       请输入账号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, account); </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;       请输入密码：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, password);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; number; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(user[i].ID, account) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(user[i].password, password) == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       登录成功，即将进入系统\n&quot;</span>);    </span><br><span class="line">            <span class="built_in">log</span> = <span class="number">1</span>;</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            UserM(); </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       你的用户名或者密码输入错误，请重新输入\n\a&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">savefile</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *file;</span><br><span class="line">    fopen(<span class="string">&quot;C:\\驾校系统资源库\\user.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; number; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(file, <span class="string">&quot;%s %s %s\n&quot;</span>, user[i].ID, user[i].password, user[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">readfile</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;C:\\驾校系统资源库\\user.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (feof(file)) <span class="keyword">break</span>;</span><br><span class="line">            i = number;</span><br><span class="line">            <span class="built_in">fscanf</span>(file, <span class="string">&quot;%s %s %s\n&quot;</span>, user[i].ID, user[i].password, user[i].name);</span><br><span class="line">            number++;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Getmistakes</span><span class="params">(MISTAKE MIS)</span> &#123;</span><br><span class="line">    FILE *fp1;</span><br><span class="line">    <span class="type">char</span> ch1,ch2,ch,id1,id2,id3,id4,id5;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j,k,m,n,id,account;</span><br><span class="line">    <span class="type">int</span> misid[<span class="number">1000</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> mistext[N];</span><br><span class="line">    <span class="keyword">if</span> ((fp1=fopen(<span class="string">&quot;C:\\驾校系统资源库\\mistakes.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>))==<span class="literal">NULL</span>) &#123; <span class="comment">//判断文件是否打开成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;很抱歉，打开错题记录文件失败，请尝试创建相关文件以继续使用\n\a&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch != EOF) &#123;.                                        <span class="comment">//获取错题文件中的用户ID</span></span><br><span class="line">        ch = fgetc(fp1);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!i) &#123;</span><br><span class="line">            id1 = ch;</span><br><span class="line">            id2 = fgetc(fp1);</span><br><span class="line">            id3 = fgetc(fp1);</span><br><span class="line">            id4 = fgetc(fp1);</span><br><span class="line">            id5 = fgetc(fp1);</span><br><span class="line">            id=((<span class="type">int</span>)id1<span class="number">-48</span>)*<span class="number">10000</span>+((<span class="type">int</span>)id2<span class="number">-48</span>)*<span class="number">1000</span>+((<span class="type">int</span>)id3<span class="number">-48</span>)*<span class="number">100</span>+((<span class="type">int</span>)id4<span class="number">-48</span>)*<span class="number">10</span>+(<span class="type">int</span>)id5<span class="number">-48</span>;</span><br><span class="line"><span class="comment">//注意转换</span></span><br><span class="line">            misid[i++]=id;                                            <span class="comment">//存放用户ID</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            id1 =fgetc(fp1) ;</span><br><span class="line">            id2 = fgetc(fp1);</span><br><span class="line">            id3 = fgetc(fp1);</span><br><span class="line">            id4 = fgetc(fp1);</span><br><span class="line">            id5 = fgetc(fp1);</span><br><span class="line">            id=((<span class="type">int</span>)id1<span class="number">-48</span>)*<span class="number">10000</span>+((<span class="type">int</span>)id2<span class="number">-48</span>)*<span class="number">1000</span>+((<span class="type">int</span>)id3<span class="number">-48</span>)*<span class="number">100</span>+((<span class="type">int</span>)id4<span class="number">-48</span>)*<span class="number">10</span>+(<span class="type">int</span>)id5<span class="number">-48</span>;</span><br><span class="line"><span class="comment">//注意转换</span></span><br><span class="line">            misid[i++]=id;                                            <span class="comment">//存放用户ID</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入用户ID\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;account);</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    MIS.userid=account;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(misid[j]==account) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rewind(fp1);                                                <span class="comment">//使光标返回文件头</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;j; k++)</span><br><span class="line">        moveToNextLine(fp1);                                    <span class="comment">//使光标向下移动一行</span></span><br><span class="line">    n=Getmis(fp1,mistext);</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>; m&lt;n; m++) &#123;</span><br><span class="line">        MIS.mistakes[m]=mistext[m];</span><br><span class="line">    &#125;</span><br><span class="line">    mistest(n,MIS);</span><br><span class="line"> </span><br><span class="line">    fclose(fp1);                                                <span class="comment">//关闭文件</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">moveToNextLine</span><span class="params">(FILE *fp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        c = fgetc(fp);</span><br><span class="line">        <span class="keyword">if</span>(c == EOF) <span class="keyword">return</span> EOF;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">Getmis</span><span class="params">(FILE *fp1,<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch1,ch2,ch3,ch5,ch=<span class="string">&#x27;a&#x27;</span>,id1,id2,id3,id4,id5;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j,k,id,account,ch4;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(ch1!= <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        ch = fgetc(fp1);</span><br><span class="line">        <span class="keyword">while</span>(ch==<span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line"> </span><br><span class="line">            ch1= fgetc(fp1);</span><br><span class="line">            <span class="keyword">if</span>(ch1==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">            ch2=fgetc(fp1);</span><br><span class="line">            <span class="keyword">if</span>(ch2!=<span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                ch3=fgetc(fp1);</span><br><span class="line">                <span class="keyword">if</span>(ch3!=<span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                    ch4=((<span class="type">int</span>)ch1<span class="number">-48</span>)*<span class="number">100</span>+((<span class="type">int</span>)ch2<span class="number">-48</span>)*<span class="number">10</span>+(<span class="type">int</span>)ch3<span class="number">-48</span>;</span><br><span class="line">                    a[i++]=ch4;</span><br><span class="line">                    ch4=fgetc(fp1);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ch4=((<span class="type">int</span>)ch1<span class="number">-48</span>)*<span class="number">10</span>+(<span class="type">int</span>)ch2<span class="number">-48</span>;</span><br><span class="line">                    a[i++]=ch4;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ch4=(<span class="type">int</span>)ch1<span class="number">-48</span>;</span><br><span class="line">                a[i++]=ch4;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mistest</span><span class="params">(<span class="type">int</span> n,MISTAKE MIS)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>,count2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag,m;</span><br><span class="line">    text_answer a;</span><br><span class="line">    <span class="type">char</span> ch1,ans;</span><br><span class="line">    <span class="type">char</span> choice2;</span><br><span class="line">    FILE *fp,*fp1;</span><br><span class="line">    <span class="type">int</span> random[M];</span><br><span class="line">    <span class="type">int</span> mis=<span class="number">0</span>,count=<span class="number">1</span>,right=<span class="number">0</span>,score=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fp1=fopen(<span class="string">&quot;C:\\驾校系统资源库\\text.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;嗯...试题库文件打开失败，请尝试联系管理员&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>((ch1=fgetc(fp1))!=EOF) &#123; </span><br><span class="line">            <span class="keyword">if</span>(ch1==<span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch1 &lt;= <span class="number">0</span> || (ch1 &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;9&#x27;</span>) || (ch1 &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;Z&#x27;</span>) || ch1 == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="comment">//把题目放到数组中，题目里的汉字在计算机存的码值小于0</span></span><br><span class="line">            &#123;</span><br><span class="line">                a.text[i][j++]=ch1;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch1&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;ch1&lt;=<span class="string">&#x27;z&#x27;</span>) </span><br><span class="line">                a.answer[k++]=ch1;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        flag=MIS.mistakes[count2++];<span class="comment">//随机抽题</span></span><br><span class="line">        <span class="keyword">if</span>((flag%<span class="number">1</span>)!=<span class="number">0</span>).                   <span class="comment">//判断随机数是否为5的倍数（题目的行号为5的倍数）</span></span><br><span class="line">            n++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">Reanswer:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d.&quot;</span>,count);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag*<span class="number">5</span>+<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag*<span class="number">5</span>+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag*<span class="number">5</span>+<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;                                               E.退出错题&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag*<span class="number">5</span>+<span class="number">3</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(a.text[flag*<span class="number">5</span>+<span class="number">4</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你选择：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ans);</span><br><span class="line">            <span class="keyword">if</span> (ans!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;ans!=<span class="string">&#x27;B&#x27;</span>&amp;&amp;ans!=<span class="string">&#x27;C&#x27;</span>&amp;&amp;ans!=<span class="string">&#x27;D&#x27;</span>&amp;&amp;ans!=<span class="string">&#x27;E&#x27;</span>) &#123; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;无效选择！请重新作答！\n&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">goto</span> Reanswer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.answer[flag]==ans+<span class="number">32</span>) &#123;                         <span class="comment">//判断答案</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n选择正确\n\n&quot;</span>);</span><br><span class="line">                right++;</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ans==<span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">Rechoose:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;是否确认退出错题？\n\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;A.是              B.否\n\n&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;choice2);</span><br><span class="line">                <span class="keyword">if</span> (choice2!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;choice2!=<span class="string">&#x27;B&#x27;</span>) &#123; <span class="comment">//判断输入的选项</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;无效选择！请重新选择！\n&quot;</span>);</span><br><span class="line">                    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">                    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">goto</span> Rechoose;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(choice2==<span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(choice2==<span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                    <span class="keyword">goto</span>  Reanswer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n选择错误，正确答案为&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c\n\n&quot;</span>,a.answer[flag/<span class="number">5</span>]<span class="number">-32</span>);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            score=<span class="number">100</span>-mis;</span><br><span class="line">            count++;</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(--n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;错题重做已结束，请继续学习，即将返回主界面。&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    UserM();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//admin.c中的代码</span></span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">showscore</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    fp=fopen(<span class="string">&quot;C:\\驾校系统资源库\\userscore.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;抱歉，打开成绩记录文件失败，请尝试创建相关文件以继续使用&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的组织内的用户成绩如下：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;提示：‘@’后是你组织成员的考试分数：\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    <span class="keyword">while</span> ((ch=fgetc(fp))!=EOF)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">fclose(fp);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line">AdminM();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">addexe</span><span class="params">()</span>。                                               <span class="comment">//添加习题</span></span><br><span class="line"> &#123;</span><br><span class="line">    FILE *fp1;</span><br><span class="line">    <span class="type">char</span> topic[N];</span><br><span class="line">    <span class="type">char</span> choice1[N];</span><br><span class="line">    <span class="type">char</span> choice2[N];</span><br><span class="line">    <span class="type">char</span> choice3[N];</span><br><span class="line">    <span class="type">char</span> choice4[N];</span><br><span class="line">    <span class="type">char</span> answer;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">if</span> ((fp1=fopen(<span class="string">&quot;C:\\驾校系统资源库\\text.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>))==<span class="literal">NULL</span>) &#123; <span class="comment">/*判断文件是否打开成功*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;嗯...试题库文件打开失败，请尝试联系管理员\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入题目：\n\n&quot;</span>);</span><br><span class="line">    gets(topic);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    <span class="built_in">fprintf</span>(fp1,<span class="string">&quot;%s&quot;</span>,topic);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,fp1);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入选项A：\n\n&quot;</span>);</span><br><span class="line">    gets(choice1);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    <span class="built_in">fprintf</span>(fp1,<span class="string">&quot;A、%s&quot;</span>,choice1);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,fp1);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入选项B：\n\n&quot;</span>);</span><br><span class="line">    gets(choice2);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    <span class="built_in">fprintf</span>(fp1,<span class="string">&quot;B、%s&quot;</span>,choice2);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,fp1);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入选项C：\n\n&quot;</span>);</span><br><span class="line">    gets(choice3);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    <span class="built_in">fprintf</span>(fp1,<span class="string">&quot;C、%s&quot;</span>,choice3);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,fp1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入选项D：\n\n&quot;</span>);</span><br><span class="line">    gets(choice4);<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp1,<span class="string">&quot;D、%s&quot;</span>,choice4);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入答案：\n\n&quot;</span>);</span><br><span class="line">answer=getchar();<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line"><span class="built_in">fprintf</span>(fp1,<span class="string">&quot;%c&quot;</span>,answer);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,fp1);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;题目已成功添加！你是否需要继续添加题目？\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1 是   2 否\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">&#125; <span class="keyword">while</span>(a!=<span class="number">1</span>&amp;&amp;a!=<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">2</span>)</span><br><span class="line">&#123;system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;试题添加已结束。 \n&quot;</span>) ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">fclose(fp1);</span><br><span class="line">ExerM();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">adminregist</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,t;</span><br><span class="line">    <span class="type">char</span> key[<span class="number">20</span>]; </span><br><span class="line">    <span class="type">int</span> reg= <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> account[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> password[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;       ************************* 现在，让我们开始添加管理员到你的组织 *************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;       只需要几步简单的操作，就可以成功添加新的管理员请按如下引导操作。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;       请注意：你注册的ID必须为5位数字\n&quot;</span>);</span><br><span class="line">a:  <span class="built_in">printf</span>(<span class="string">&quot;       请输入你想要添加的管理员ID：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, account);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strspn</span>(account, <span class="string">&quot;0123456789&quot;</span>) != <span class="built_in">strlen</span>(account))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       ★你输入的ID无效，请重新输入\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> a; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(account)!=<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       ★你输入的ID长度不合规，请重新输入：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> a;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(admin[i].ID, account) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;此管理员用户已存在，请尝试添加其他用户\n&quot;</span>);    </span><br><span class="line">            <span class="keyword">goto</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;       请输入您的密码，请注意，您的密码仅限6位：  \n&quot;</span>);</span><br><span class="line">b:    <span class="built_in">printf</span>(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, password);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(password)!=<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       ★你输入的密码长度不合规，请重新输入：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> b;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       请再次输入您的密码:  &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;key);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(key,password) == <span class="number">0</span>) </span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;       两次输入的密码不一致，请重新输入 :) \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(t == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (reg) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(admin[num].ID, account);</span><br><span class="line">        <span class="built_in">strcpy</span>(admin[num].password, password);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       请输入你的用户名: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,admin[num].name);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       搞定！\n&quot;</span>); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       管理员添加成功，现在可以开始管理系统了\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    AdminM(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">adminsavefile</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;C:\\驾校系统资源库\\admin.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(file, <span class="string">&quot;%s %s %s\n&quot;</span>, admin[i].ID, admin[i].password, admin[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">adminreadfile</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;C:\\驾校系统资源库\\admin.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (feof(file)) <span class="keyword">break</span>;</span><br><span class="line">            i = num;</span><br><span class="line">            <span class="built_in">fscanf</span>(file, <span class="string">&quot;%s %s %s\n&quot;</span>, admin[i].ID, admin[i].password, admin[i].name);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">adminlogin</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">log</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> account[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> password[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n       ************************* 如果你拥有管理员账户，请登录 *************************\n&quot;</span>);</span><br><span class="line">   c: <span class="built_in">printf</span>(<span class="string">&quot;       请输入账号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, account); </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;       请输入密码：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, password);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(admin[i].ID, account) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(admin[i].password, password) == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       登录成功，即将进入系统\n&quot;</span>);    </span><br><span class="line">            <span class="built_in">log</span> = <span class="number">1</span>;</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            AdminM();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;      你的用户名或者密码输入错误，请重新输入\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//menu.c中的代码</span></span><br><span class="line"><span class="type">int</span> cyn;</span><br><span class="line"><span class="comment">//总菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MainM</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;************ 欢迎使用 驾考通·驾驶员科目一模拟系统 ****************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                                 *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*       1 管理员点这里            2 普通用户点这里                *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                                 *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                     0 退出程序                                  *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                                 *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************************************************************\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    &#125; <span class="keyword">while</span> (n!=<span class="number">1</span>&amp;&amp;n!=<span class="number">2</span>&amp;&amp;n!=<span class="number">0</span>);<span class="comment">//读取用户输入的值，并进行相应跳转</span></span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在进入管理员系统，请稍候...\n&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;CLS&quot;</span>);</span><br><span class="line">            AdminSM();  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在进入用户系统，请稍候...\n&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;CLS&quot;</span>);</span><br><span class="line">            UserSM();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;程序已退出!\n\a&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用户部分</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//用户主菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UserSM</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************  欢迎！ *********************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                                 *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*       1 我已经拥有账号（登录）     2 没有账号？（注册一个！）   *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                                 *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                          0 返回                                 *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                                 *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************************************************************\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    &#125; <span class="keyword">while</span> (a!=<span class="number">1</span>&amp;&amp;a!=<span class="number">2</span>&amp;&amp;a!=<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            readfile();</span><br><span class="line">            cyn=login();<span class="comment">//登录系统（已完成） </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            readfile();</span><br><span class="line">            regist();</span><br><span class="line">            savefile();<span class="comment">//注册系统（已完成） </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            MainM();<span class="comment">//返回主菜单（已完成）</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用户分菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UserM</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**********************   祝你学习愉快   ************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                              *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                  1 知识学习     2 模拟测试                   *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                  3 错题重做                                  *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                              *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                          0 退出登录                          *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                              *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************************************************************\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    &#125; <span class="keyword">while</span> (a!=<span class="number">1</span>&amp;&amp;a!=<span class="number">2</span>&amp;&amp;a!=<span class="number">0</span>&amp;&amp;a!=<span class="number">3</span>&amp;&amp;a!=<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            studytest(); <span class="comment">//学习系统（已完成） </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            test(cyn);<span class="comment">//测验系统（已完成）</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            Getmistakes(MIS);<span class="comment">//错题重做 </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            UserSM();<span class="comment">//返回用户主菜单（已完成） </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//管理员部分</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//管理员主菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdminSM</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************  欢迎！ ****************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                            *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                       1 管理员登录                         *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                            *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                       0 返回上一级                         *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                            *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**************************************************************\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    &#125; <span class="keyword">while</span> (a!=<span class="number">1</span>&amp;&amp;a!=<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            adminreadfile();<span class="comment">//管理员登录（已完成） </span></span><br><span class="line">            adminlogin(); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            MainM();<span class="comment">//返回总菜单 （已完成） </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//管理员分菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdminM</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;********************  驾考通·后台管理系统   ********************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                               *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*              1 题库管理            2 成绩查看                 *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                       3 添加管理员                            *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                       0 退出登录                              *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                               *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*****************************************************************\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    &#125; <span class="keyword">while</span> (a!=<span class="number">1</span>&amp;&amp;a!=<span class="number">2</span>&amp;&amp;a!=<span class="number">0</span>&amp;&amp;a!=<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请稍等，我们正在进入题库...&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            ExerM() ;<span class="comment">//进入题库菜单（已完成） </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            showscore(); <span class="comment">//成绩查看（已完成） </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            adminreadfile();</span><br><span class="line">            adminregist();</span><br><span class="line">            adminsavefile();<span class="comment">//添加管理员（已完成） </span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            AdminSM();<span class="comment">//返回管理员主菜单 </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//题库管理菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ExerM</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*********************  驾考通·题库管理系统  ********************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                               *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                  1 增加试题     2 删除编辑试题                *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                  3 返回上页                                   *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                               *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                        0 退出登录                             *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                               *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*****************************************************************\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    &#125; <span class="keyword">while</span> (a!=<span class="number">1</span>&amp;&amp;a!=<span class="number">2</span>&amp;&amp;a!=<span class="number">0</span>&amp;&amp;a!=<span class="number">3</span>&amp;&amp;a!=<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//增加试题（已完成） </span></span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            addexe();   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//删除编辑试题（已完成） </span></span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;题目编辑涉及错题系统变更\n&quot;</span>); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请前往文件夹：桌面-驾校系统资源库-text.txt对该文本文件进行修改\n&quot;</span>) ;</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            ExerM(); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            AdminM();<span class="comment">//返回管理员分菜单（已完成） </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            AdminSM();<span class="comment">//返回管理员主菜单（已完成） </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>LATEX公式使用</title>
    <url>/2023/09/15/2023/LATEX%E5%85%AC%E5%BC%8F%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>一些实用的技术</p>
</blockquote>
<span id="more"></span>
<h1 id="前言">前言</h1>
<blockquote>
<p>最近在想写博客的时候发现我不太会用latex公式，就准备学一学</p>
<p>网上有太多教程了，我就不重复劳动了，把一些重要的常用的copy下来，其他的转载</p>
</blockquote>
<h1 id="如何插入公式">如何插入公式</h1>
<p><code>𝐿𝐴𝑇𝐸𝑋</code>
的数学公式有两种：行中公式和独立公式（行间公式）。行中公式放在文中与其它文字混编，独立公式单独成行。</p>
<p>行中公式可以用如下方法表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ 数学公式 $</span><br></pre></td></tr></table></figure>
<p>独立公式可以用如下方法表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ 数学公式 $$</span><br></pre></td></tr></table></figure>
<h3 id="标准函数">标准函数<a
href="https://www.cnblogs.com/1024th/p/11623258.html#2083047927">#</a></h3>
<p>指数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\exp_a b = a^b, \exp b = e^b, 10^m</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\exp_a b = a^b, \exp b = e^b, 10^m
\]</span></p>
<p>对数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\ln c, \lg d = \log e, \log_&#123;10&#125; f</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\ln c, \lg d = \log e, \log_{10} f
\]</span></p>
<p>三角函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\sin a, \cos b, \tan c, \cot d, \sec e, \csc f</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\sin a, \cos b, \tan c, \cot d, \sec e, \csc f
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\arcsin a, \arccos b, \arctan c</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\arcsin a, \arccos b, \arctan c
\]</span></p>
<p>其余请看这篇博文<a
href="https://www.cnblogs.com/1024th/p/11623258.html">LaTeX公式手册(全网最全)</a></p>
]]></content>
      <categories>
        <category>LATEX</category>
      </categories>
      <tags>
        <tag>LATEX</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2023/01/29/2023/hello-world/</url>
    <content><![CDATA[<p>欢迎来到我的博客！</p>
]]></content>
  </entry>
  <entry>
    <title>二叉树遍历简单做法</title>
    <url>/2023/02/09/2023/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%80%E5%8D%95%E5%81%9A%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>看王道数据结构考研复习有感</p>
</blockquote>
<span id="more"></span>
<h1 id="问题">问题</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt="二叉树" style="zoom:33%;" /></p>
<p>给出如图所示二叉树，请你分别对其进行前序、中序、后序遍历并给出遍历结果。</p>
<h1 id="解答">解答</h1>
<p>这里我们除了可以用编程思想一步一步进行遍历，还有一种更为简单快速的方法，这里我称它画图法。</p>
<h2 id="步骤一">步骤一</h2>
<p>我们先在每个结点旁画上小圆点，这里我们以前序遍历为例，在结点左侧画上小圆点。（中序遍历在下侧，后序遍历在右侧）</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/%E5%89%8D%E5%BA%8F.PNG" alt="前序" style="zoom:33%;" /></p>
<h2 id="步骤二">步骤二</h2>
<p>以根节点上方为起点，从左侧贴着二叉树画线穿过小圆点，绕一周回到起点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/%E5%89%8D%E5%BA%8F2.PNG" alt="前序2" style="zoom:33%;" /></p>
<h2 id="步骤三">步骤三</h2>
<p>穿过小圆点的先后顺序便是遍历的结果。 这次遍历的结果为：</p>
<center>
<font color=Tomato size=6>前序：ABDECFHG</font>
</center>
<p>这样我们也能得到中序和后序遍历的结果了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/%E4%B8%AD%E5%BA%8F.PNG" alt="中序" style="zoom:33%;" /></p>
<center>
<font color=Tomato size=6>中序：DBEAFHCG</font>
</center>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/%E5%90%8E%E5%BA%8F.PNG" alt="后序" style="zoom:33%;" /></p>
<center>
<font color=Tomato size=6>后序：DEBHFGCA</font>
</center>
]]></content>
      <categories>
        <category>学科</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Taihub分享</title>
    <url>/2023/02/01/2023/Taihub%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<blockquote>
<p>关于泰的一切</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/IMG_1790.PNG" alt="IMG_1790" style="zoom: 25%;" /></p>
</blockquote>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>孝泰是由2021年夏天一个视频引发的小众亚文化圈子，发展至今，已诞生了多数优秀的作品。在这里我进行了不完全的整理并放在了网盘上，请自行取用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/IMG_1790.PNG" alt="IMG_1790" style="zoom: 25%;" /></p>
<h1 id="链接">链接</h1>
<p>https://pan.baidu.com/s/1IqRYFEZJGfA_Bg0yNdBY5w?pwd=6sa7
提取码：6sa7</p>
<h1 id="使用须知">使用须知</h1>
<p>正作是tai原素材包含视频和图片多数来源于cj 番外是tai整活视频
DLC是tai整活图片 借物表不填写⚪ 二配允许⚪ 修改允许⚪ 商用不允许×
R18不允许×</p>
<h1 id="补档">补档</h1>
<h2 id="补档1">补档1</h2>
<p>​
孝泰为什么是神？在谈论这个问题之前，我想先说说其他梗王相较于孝泰究竟差在了哪里</p>
<h3 id="首先是犯下傲慢之罪的哲学众将">首先是犯下傲慢之罪的哲学众将</h3>
<p>​
凭着niconico留下来的热度，在B站掀起一波腥风血雨，这种亚文化梗注定走不长远，事实也是如此，18年被B站制裁了之后就泯然众人，仅维持着一点热度。与之相比神就很谦卑，嘞个mang，李个逼都是神留给凡人的慈悲，神不是没有好的口头禅，只是不想通过太完美的言语让大家折服而故意不用，可笑有些人不理解神的良苦用心，竟然还用这些事来讥讽神，我劝你们好自为之。</p>
<h3 id="然后是犯下愤怒之罪的虎哥">然后是犯下愤怒之罪的虎哥</h3>
<p>​
因为杀马特团长与其的口角争斗，就愤怒地与团长进行约战，违背了神在《新约》中的一句话:“还森两百多天吧，我的话就似想和大家缩，尽力zhuo到坠好的自己吧。”于是神降下了他的惩罚，虎哥不见踪影，落寞生活。</p>
<h3 id="接着是犯下懒惰之罪的初音">接着是犯下懒惰之罪的初音</h3>
<p>​
自以为拿下几个畅销冠军就了不起了，自创歌姬计划。另外大家有所不知，其实每次初音发歌前，初音闭上眼睛做冥想的时候，其脑海中看见的画面，正是站在光芒之中的孝泰，那时神告诉她：“李只可到这里，不可越过。”然而，神的劝说不但没有让初音迷途知返，竟敢还不断发游戏发周边正面挑战神的威严，于是神降下了他的惩罚，初音热度渐渐下降，从公主殿下变成了葱。</p>
<h3 id="再然后是犯下了嫉妒之罪的子润">再然后是犯下了嫉妒之罪的子润</h3>
<p>​
热度屡次被神击败，但口服心不服的子润，暗中嫉妒着神，甚至胆敢在赵睿英面前挑明和张国的关系。于是，在含金量更高的热度对决，即处男帮里，子润被孝泰正面击溃。不过，念在都是一个班的份上，并且践行了神的意志吸引力屡次吼神的赵睿英的火力后，神应许了他在一班的一切。</p>
<h3 id="犯下贪婪之罪的刘华强">犯下贪婪之罪的刘华强</h3>
<p>​
只是部老剧，华强就夺得了2021年B站热度榜单，而这，自然是因为神的应许。神本来钦定他为自己在人间的代言人，在自己热度下去后替自己继续火热全网，为此甚至不惜亲自为华强铺路，主动退出B站圈，将一切荣耀都归给他，甚至应许他可以带走自己最爱的瓜。但最后华强却被利益蒙蔽了双眼，不再以践行神的理想为自己的理想，也不再聆听神的教诲，甚至自以荣光已经超过了神，竟允许粉丝P出孝泰卖瓜这种亵渎神尊严的图片，于是神降下了惩罚，华强从此不再正常并且拥有各种形态，而他的电瓶车将再也不能载起他最初的梦想，他的刀再也不能正常地劈瓜，他的瓜摊老板再也不能正常地发觉不对劲。</p>
<h3 id="犯下暴食之罪的嘉然">犯下暴食之罪的嘉然</h3>
<p>​
在神子华强开始堕落之后，神开始寻找下一个代言人，这一次，他选中了嘉然。相较于神，嘉然无疑是不完美的，他没有神足以让众人沦陷的样貌，也没有神深不见底的名句池，舍我其谁的胆气，敏锐的词汇选择，无懈可击的步伐，但神将自己最虔诚，同时也是实力最强大的两位泰心糖暂时交给了她，并复刻了为华强的铺路操作，但由于高考的事，神认为或许是自己给的压力过大才导致了华强的堕落，于是这一次神选择了去南通，减少嘉然的心理负担，最终，嘉然成功了。然而，获得热度的嘉然不但冒大不韪给两位泰心糖新的称号嘉心糖，更妄图染指神力，只是她错误地认为身的力量来源于语言的步伐，最终她也因此犯下了暴食之罪，并得到了一大推屁用没有的嘉心糖。</p>
<h3 id="最后犯下淫欲之罪的吴乘风">最后，犯下淫欲之罪的吴乘风</h3>
<p>​
2021暑假之后，神已经非常虚弱了，原神用氪金系统吸走了神的精气，神已经无力再惩罚嘉然，只有两位信徒依旧在维护神的尊严而已。此刻已经决心退隐的神在最后依然心系苏州，于是他选中了第三位神子——吴乘风。作为第三任神子，吴乘风很好地维护了神的尊严，但接连击溃鼓楼的窑子后，吴乘风遇到了石佛寺三宫四十八号的浦口淫魔，被吸走了神赋予自己的力量，于是在班干竞选中节节败退，最终泯然众人，活在男人窝中。</p>
<h2 id="补档2">补档2</h2>
<p>​
2021年的最后一个16号已经过去一天，孝泰的补档已成终章，不管是好活还是烂活，重要的是慢慢的，大家，把所谓的烂活，好活……讲成了一个故事，变成了一种艺术。朦胧的感觉，迷茫的感觉，大家最初单纯只是喜欢恶搞，喜欢玩乐，渐渐的渐渐的喜欢上了孝泰的真实。
不真实的，真实</p>
<p>​
那些视频我看了不下50次，最初点进去是抱着无厘头的态度看一个搞笑的抽象作品的，可没想到我被彻底的震撼到了，忍不住的看了一次又一次。</p>
<p>​
多年前模糊的画质，夏日漱石的配乐，王家卫文艺的台词，孝泰荒诞行为的画面。这一切听起来不可思议甚至有些魔幻的组合却拼接的是那么的恰到好处，想要赋予视频意义的同时又在鼓励观众尝试解构一帧帧画面。</p>
<p>​
狭窄的房间，失意的男人，狂乱的肢体动作，整部作品都旨在表达一种荒谬感，一种充斥着整个人类历史的荒诞无稽。这里没有什么东西是有价值可言的，宇宙冷漠而荒谬，而人在真正面对它时，一切的现实和理智都将崩溃</p>
<p>​ 我愿称之为荒诞浪漫主义的开端，甚至将引领一段不可思议的潮流。</p>
<p>你问我什么是荒诞浪漫主义？ 是莫扎特谱写的朋克摇滚乐，
是梵高画出的二次元美少女， 是曹雪芹写下的凡人修仙传，
是李白导演出的商业谍战片， 是方文山创作出的让子弹飞，
是和孝泰度过的那一个夏天。</p>
<p>​
今天是17号。我错过了16号的补档，正如我错过了那个夏天。还记得第一次看完了视频，我惊讶于孝泰的舞蹈，看完了评论，我想哭，我想笑，我想此刻在寒冷的的冬天穿着短袖去操场上跑圈，我想和视频里的孝泰一样做一些荒诞又浪漫的事情，我想有一个无悔的青春。我想说很多话，我想做很多事，可是到最后什么也没说，什么也没做。我羡慕孝泰，真的，他把生活过成了戏剧，又在每个16号都被常常记起，当没有人再放这些视频的时候，当孝泰被科技城遗忘的时候，孝泰才能真正活在南通吧</p>
<h2 id="补档3">补档3</h2>
<p>是枕绿色围巾孝泰的睡姿 是上课孝泰不断闭眼点头 是红衣孝泰李个逼的声波
是孝泰蓝色三叶草T恤衫 是体育馆孝泰飞出的鞋垫 是丝滑无法复制孝泰转身
是钉钉视频孝泰蓝刨冰机 是一张张照片孝泰的中指 是孝泰经典套司波登大衣
是羽毛球馆孝泰梦幻脚步 是孝泰气喘喘的相当不绰 是孝泰撑起来的零号特工
是还森两百多天南大孝泰 是通大电科孝泰五天早八 是不可能被五等分的孝泰</p>
<h2 id="补档4">补档4</h2>
<p>我好想做孝泰的狗啊。</p>
<p>可是孝泰说他喜欢的是他小弟，我哭了。</p>
<p>我知道既不是狗也不是小弟的我为什么要哭的。因为我其实是他的同学。</p>
<p>我从没奢望孝泰能看一眼自己。我明白的，所有人都喜欢理解余裕上手天才打钱的萌萌的狗狗或者小弟，没有人会喜欢只会躲在阴暗角落的同学。</p>
<p>但我还是问了孝泰:“我能不能做你的狗？”</p>
<p>我知道我是注定做不了狗的。但如果他喜欢狗，我就可以一直在身边看着他了，哪怕她怀里抱着的永远都是狗。</p>
<p>可是他说喜欢的是他小弟。</p>
<p>他现在还能看我，还在和我说话，是因为他小弟还没有出现，只有我这同学每天蹑手蹑脚地从阴暗角落里爬出来，远远地和他对视。</p>
<p>等他喜欢的小弟来了的时候，我就该重新滚回我的座位了吧。</p>
<p>但我还是好仰慕他，他能在我还在他身边的时候多看我几眼吗？</p>
<p>孝泰说接下来的每个圣诞夜都要和大家一起过。我不知道大家指哪些人。好希望这个集合能够对我做一次胞吞。</p>
<p>他小弟还在害怕孝泰。</p>
<p>我会去把他爱的小弟引来的。</p>
<p>我知道稍有不慎，我就会请他小弟吃某利来冰山熔岩蛋糕。</p>
<p>那时候孝泰大概会往我身上扔臭鸡蛋吧。</p>
<p>那我就成了贤蛋黄，嘻嘻。</p>
<p>我希望他能把我扔得近一点，因为我还是好仰慕他。会一直仰慕下去的。</p>
<p>我的灵魂透过窗户向里面看去，挂着的铃铛在轻轻鸣响，孝泰慵懒地靠在沙发上，表演得非常温顺的小弟坐在他的身旁。壁炉的火光照在他的脸庞，我冻僵的心脏在风里微微发烫。</p>
]]></content>
      <categories>
        <category>Tai</category>
      </categories>
      <tags>
        <tag>Tai</tag>
      </tags>
  </entry>
  <entry>
    <title>美赛O奖论文研读有感</title>
    <url>/2023/02/11/2023/%E7%BE%8E%E8%B5%9BO%E5%A5%96%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<blockquote>
<p>美赛O奖论文研读有感</p>
</blockquote>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>最近我在备战数学建模美赛时，重点研读了两篇O奖论文，一篇是宋浩然大佬仿照的的2020年A题的论文，另一篇是2020年C题的一篇O奖论文。</p>
<h1 id="经验">经验</h1>
<h2 id="关于突出点">关于突出点</h2>
<p>两篇论文都使用了大量图片去佐证自己的观点，而且图片都很工整好看，很吸引人。不仅是流程图，它们也将数据可视化做到极致，真正做到了直观+美观。</p>
<h2 id="关于编程">关于编程</h2>
<p>两篇论文都使用到了<code>Matlab</code>和<code>Python</code>语言，Python可能在处理大数据上有着更大的优势，因为Python的各种第三方包使用起来实在很方便，学习成本也低。这里我推荐两本学习用Python做数据分析的书：</p>
<blockquote>
<p>《利用Python进行数据分析第二版》：主要内容是数据处理，pandas，numpy，matplotlib的使用方法，较为详细</p>
<p>《Python数据科学手册》：一部分和上面那本内容重叠，后面也有讲一些机器学习模型的介绍和使用</p>
</blockquote>
<h2 id="关于图片">关于图片</h2>
<p>两篇论文的图片都很精美，图片像流程图之类的可以用PPT或者亿图图示之类的软件画，像数据可视化则可以使用Python来完成，比如使用第三方库<code>matplotlib</code>进行绘图。</p>
]]></content>
      <categories>
        <category>学科</category>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>美赛</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：递归解题三部曲</title>
    <url>/2023/03/13/2023/%E8%BD%AC%E8%BD%BD%EF%BC%9A%E9%80%92%E5%BD%92%E8%A7%A3%E9%A2%98%E4%B8%89%E9%83%A8%E6%9B%B2/</url>
    <content><![CDATA[<blockquote>
<p>转载</p>
</blockquote>
<span id="more"></span>
<p><strong>递归解题三部曲</strong></p>
<p>何为递归？程序反复调用自身即是递归。</p>
<p>我自己在刚开始解决递归问题的时候，总是会去纠结这一层函数做了什么，它调用自身后的下一层函数又做了什么…然后就会觉得实现一个递归解法十分复杂，根本就无从下手。</p>
<p>相信很多初学者和我一样，这是一个思维误区，一定要走出来。既然递归是一个反复调用自身的过程，这就说明它每一级的功能都是一样的，<strong>因此我们只需要关注一级递归的解决过程即可。</strong></p>
<p><a href="https://z3.ax1x.com/2021/09/05/hWr1UK.png"><img
src="https://z3.ax1x.com/2021/09/05/hWr1UK.png" alt="img" /></a></p>
<p>如上图所示，我们需要关心的主要是以下三点：</p>
<ol type="1">
<li>整个递归的终止条件。</li>
<li>一级递归需要做什么？</li>
<li>应该返回给上一级的返回值是什么？</li>
</ol>
<p><strong>因此，也就有了我们解递归题的三部曲：</strong></p>
<ol type="1">
<li><strong>找整个递归的终止条件：递归应该在什么时候结束？</strong></li>
<li><strong>找返回值：应该给上一级返回什么信息？</strong></li>
<li><strong>本级递归应该做什么：在这一级递归中，应该完成什么任务？</strong></li>
</ol>
<p>一定要理解这3步，这就是以后递归秒杀算法题的依据和思路。</p>
<p>但这么说好像很空，我们来以题目作为例子，看看怎么套这个模版，相信3道题下来，你就能慢慢理解这个模版。之后再解这种套路递归题都能直接秒了。</p>
<h2
id="例1求二叉树的最大深度"><strong>例1：求二叉树的最大深度</strong></h2>
<p>先看一道简单的Leetcode题目： <a
href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">Leetcode
104. 二叉树的最大深度</a></p>
<p>题目很简单，求二叉树的最大深度，那么直接套递归解题三部曲模版：</p>
<ol type="1">
<li><strong>找终止条件。</strong>
什么情况下递归结束？当然是树为空的时候，此时树的深度为0，递归就结束了。</li>
<li><strong>找返回值。</strong>
应该返回什么？题目求的是树的最大深度，我们需要从每一级得到的信息自然是当前这一级对应的树的最大深度，因此我们的返回值应该是当前树的最大深度，这一步可以结合第三步来看。</li>
<li><strong>本级递归应该做什么。</strong>
首先，还是强调要走出之前的思维误区，递归后我们眼里的树一定是这个样子的，看下图。此时就三个节点：root、root.left、root.right，其中根据第二步，root.left和root.right分别记录的是root的左右子树的最大深度。那么本级递归应该做什么就很明确了，自然就是在root的左右子树中选择较大的一个，再加上1就是以root为根的子树的最大深度了，然后再返回这个深度即可。</li>
</ol>
<p><a href="https://z3.ax1x.com/2021/09/05/hWr724.png"><img
src="https://z3.ax1x.com/2021/09/05/hWr724.png" alt="img" /></a></p>
<p>具体Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件：当树为空时结束递归，并返回当前深度0</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//root的左、右子树的最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">//返回的是左右子树的最大深度+1</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当足够熟练后，也可以和Leetcode评论区一样，很骚的几行代码搞定问题，让之后的新手看的一脸懵逼(这道题也是我第一次一行代码搞定一道Leetcode题)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例2两两交换链表中的节点">例2：两两交换链表中的节点</h2>
<p>看了一道递归套路解决二叉树的问题后，有点套路搞定递归的感觉了吗？我们再来看一道Leetcode中等难度的链表的问题，掌握套路后这种中等难度的问题真的就是秒：<a
href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">Leetcode
24. 两两交换链表中的节点</a></p>
<p>直接上三部曲模版：</p>
<ol type="1">
<li><strong>找终止条件。</strong>
什么情况下递归终止？没得交换的时候，递归就终止了呗。因此当链表只剩一个节点或者没有节点的时候，自然递归就终止了。</li>
<li><strong>找返回值。</strong>
我们希望向上一级递归返回什么信息？由于我们的目的是两两交换链表中相邻的节点，因此自然希望交换给上一级递归的是已经完成交换处理，即已经处理好的链表。</li>
<li><strong>本级递归应该做什么。</strong>
结合第二步，看下图！由于只考虑本级递归，所以这个链表在我们眼里其实也就三个节点：head、head.next、已处理完的链表部分。而本级递归的任务也就是交换这3个节点中的前两个节点，就很easy了。</li>
</ol>
<p><a href="https://z3.ax1x.com/2021/09/05/hWrva6.png"><img
src="https://z3.ax1x.com/2021/09/05/hWrva6.png" alt="img" /></a></p>
<p>附上Java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      	<span class="comment">//终止条件：链表只剩一个节点或者没节点了，没得交换了。返回的是已经处理好的链表</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//一共三个节点:head, next, swapPairs(next.next)</span></span><br><span class="line">      	<span class="comment">//下面的任务便是交换这3个节点中的前两个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">      	<span class="comment">//根据第二步：返回给上一级的是当前已经完成交换后，即处理好了的链表部分</span></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例3平衡二叉树">例3：平衡二叉树</h2>
<p>相信经过以上2道题，你已经大概理解了这个模版的解题流程了。</p>
<p>那么请你先不看以下部分，尝试解决一下这道easy难度的Leetcode题（个人觉得此题比上面的medium难度要难）：<a
href="https://leetcode-cn.com/problems/balanced-binary-tree/comments/">Leetcode
110. 平衡二叉树</a></p>
<p>我觉得这个题真的是集合了模版的精髓所在，下面套三部曲模版：</p>
<ol type="1">
<li><p><strong>找终止条件。</strong>
什么情况下递归应该终止？自然是子树为空的时候，空树自然是平衡二叉树了。</p></li>
<li><p><strong>应该返回什么信息：</strong></p>
<p>为什么我说这个题是集合了模版精髓？正是因为此题的返回值。要知道我们搞这么多花里胡哨的，都是为了能写出正确的递归函数，因此在解这个题的时候，我们就需要思考，我们到底希望返回什么值？</p>
<p>何为平衡二叉树？平衡二叉树即左右两棵子树高度差不大于1的二叉树。而对于一颗树，它是一个平衡二叉树需要满足三个条件：<strong>它的左子树是平衡二叉树，它的右子树是平衡二叉树，它的左右子树的高度差不大于1</strong>。换句话说：如果它的左子树或右子树不是平衡二叉树，或者它的左右子树高度差大于1，那么它就不是平衡二叉树。</p>
<p>而在我们眼里，这颗二叉树就3个节点：root、left、right。那么我们应该返回什么呢？如果返回一个当前树是否是平衡二叉树的boolean类型的值，那么我只知道left和right这两棵树是否是平衡二叉树，无法得出left和right的高度差是否不大于1，自然也就无法得出root这棵树是否是平衡二叉树了。而如果我返回的是一个平衡二叉树的高度的int类型的值，那么我就只知道两棵树的高度，但无法知道这两棵树是不是平衡二叉树，自然也就没法判断root这棵树是不是平衡二叉树了。</p>
<p>因此，这里我们返回的信息应该是既包含子树的深度的int类型的值，又包含子树是否是平衡二叉树的boolean类型的值。可以单独定义一个ReturnNode类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnNode</span>&#123;</span><br><span class="line">  <span class="type">boolean</span> isB;</span><br><span class="line">  <span class="type">int</span> depth;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ReturnNode</span><span class="params">(<span class="type">boolean</span> isB, <span class="type">int</span> depth)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.isB = isB;</span><br><span class="line">    <span class="built_in">this</span>.depth = depth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>本级递归应该做什么。</strong>
知道了第二步的返回值后，这一步就很简单了。目前树有三个节点：root，left，right。我们首先判断left子树和right子树是否是平衡二叉树，如果不是则直接返回false。再判断两树高度差是否不大于1，如果大于1也直接返回false。否则说明以root为节点的子树是平衡二叉树，那么就返回true和它的高度。</p></li>
</ol>
<p>具体的Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//这个ReturnNode是参考我描述的递归套路的第二步：思考返回值是什么</span></span><br><span class="line">    <span class="comment">//一棵树是BST等价于它的左、右俩子树都是BST且俩子树高度差不超过1</span></span><br><span class="line">    <span class="comment">//因此我认为返回值应该包含当前树是否是BST和当前树的高度这两个信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ReturnNode</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> isB;</span><br><span class="line">        <span class="type">int</span> depth;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReturnNode</span><span class="params">(<span class="type">int</span> depth, <span class="type">boolean</span> isB)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.isB = isB;</span><br><span class="line">            <span class="built_in">this</span>.depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isBST(root).isB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参考递归套路的第三部：描述单次执行过程是什么样的</span></span><br><span class="line">    <span class="comment">//这里的单次执行过程具体如下：</span></span><br><span class="line">    <span class="comment">//是否终止?-&gt;没终止的话，判断是否满足不平衡的三个条件-&gt;返回值</span></span><br><span class="line">    <span class="keyword">public</span> ReturnNode <span class="title function_">isBST</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnNode</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不平衡的情况有3种：左树不平衡、右树不平衡、左树和右树差的绝对值大于1</span></span><br><span class="line">        <span class="type">ReturnNode</span> <span class="variable">left</span> <span class="operator">=</span> isBST(root.left);</span><br><span class="line">        <span class="type">ReturnNode</span> <span class="variable">right</span> <span class="operator">=</span> isBST(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left.isB == <span class="literal">false</span> || right.isB == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnNode</span>(<span class="number">0</span>, <span class="literal">false</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left.depth - right.depth) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnNode</span>(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不满足上面3种情况，说明平衡了，树的深度为左右俩子树最大深度+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnNode</span>(Math.max(left.depth, right.depth) + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一些可以用这个套路解决的题">一些可以用这个套路解决的题</h2>
<p>暂时就写这么多啦，作为一个高考语文及格分，大学又学了工科的人，表述能力实在差因此啰啰嗦嗦写了一大堆，希望大家能理解这个很好用的套路。</p>
<p>下面我再列举几道我在刷题过程中遇到的也是用这个套路秒的题，真的太多了，大部分链表和树的递归题都能这么秒，因为树和链表天生就是适合递归的结构。</p>
<p>我会随时补充，正好大家可以看了上面三个题后可以拿这些题来练练手，看看自己是否能独立快速准确的写出递归解法了。</p>
<p><a
href="https://leetcode-cn.com/problems/symmetric-tree/comments/">Leetcode
101. 对称二叉树</a></p>
<p><a
href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">Leetcode
111. 二叉树的最小深度</a></p>
<p><a
href="https://leetcode-cn.com/problems/invert-binary-tree/">Leetcode
226. 翻转二叉树</a>：这个题的备注是最骚的。Mac
OS下载神器homebrew的大佬作者去面试谷歌，没做出来这道算法题，然后被谷歌面试官怼了：”我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。”</p>
<p><a
href="https://leetcode-cn.com/problems/merge-two-binary-trees/">Leetcode
617. 合并二叉树</a></p>
<p><a
href="https://leetcode-cn.com/problems/maximum-binary-tree/">Leetcode
654. 最大二叉树</a></p>
<p><a
href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">Leetcode
83. 删除排序链表中的重复元素</a></p>
<p>来自：https://lyl0724.github.io/2020/01/25/1/</p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>解题技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>重拾博客</title>
    <url>/2023/09/03/2023/%E9%87%8D%E6%8B%BE%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>经过一个学期重拾个人博客</p>
</blockquote>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>在2023年暑假的时候我创建了自己的个人博客，通过github
pages使用Hexo框架加上butterfly主题，荒废了一个学期，现在决定重新填起这个坑。</p>
<h1 id="经过">经过</h1>
<p>在寒假发了几个博客后，发现使用markdown写博客加入图片时不能做到可视化，而且当时还不知道图床这个东西，所以图片什么的都存到了本地，管理和存储起来十分麻烦，还给网站增加流量负载，所以弃坑了。</p>
<p>再后来我在CSDN上发现了南邮的一个学长的博客，名叫<a
href="https://wonzwang.blog.csdn.net/?type=blog">Wonz</a>，在他的博客中我学到了很多，也从他的友链中知道了很多学长，看着他们的博客，我也想重拾自己的坑了。</p>
<p>有时候我也想在有些触动的时候将自己的想法记录下来，但奈何自己太懒，在这个暑假我去了一个单位实习，在实习的过程中我渐渐可以熟练地使用git，也在实习的过程中产生越来越多的想法，现在实习结束了，也想总结一下，慢慢填补这个坑吧。</p>
<h1 id="准备">准备</h1>
<p>之前为了网站看起来炫酷一点，我就选择了butterfly这个主题，不过这样的代价是图片太多了，而且不够简洁，过于花里胡哨，这样对网站的加载速度也有影响，也不好将注意力放在写作上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/IMG_3840.JPG" alt="IMG_3840" style="zoom: 33%;" /></p>
<p>所以我换了个新的主题——<strong>Next主题</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230903171120400.png" alt="image-20230903171120400" style="zoom: 33%;" /></p>
<p>这个主题我是看的<a
href="https://wonz.wang/">Wonz</a>学长的个人博客在用的，十分简洁，内容清晰明了，我在暑假也看到过一段话：</p>
<blockquote>
<p>技术博客不需要弄得太花里胡哨，简单清晰才是王道。</p>
</blockquote>
<p>我看见他置顶博客的描述：</p>
<blockquote>
<p>阮一峰大神曾经说过: 喜欢写 Blog 的人, 会经历 3 个阶段。</p>
<p>第一阶段，刚接触 Blog，觉得很新鲜，试着选择一个免费空间来写。
第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。
第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
<p>我对这话深有感触，本来我也在想要不要自己搞个服务器部署博客，发现根本没必要，还不安全，有github就很方便。</p>
<h1 id="展望">展望</h1>
<p>希望接下来能静下心来，将自己的所见所想记录下来，多输出些技术博客，提升自己的竞争力吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>关于2023暑假</title>
    <url>/2023/09/15/2023/%E5%85%B3%E4%BA%8E2023%E6%9A%91%E5%81%87/</url>
    <content><![CDATA[<blockquote>
<p>给忙碌的暑假一个交代</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/IMG_2971.jpeg" style="zoom:80%;" /></p>
</blockquote>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>这篇总结拖了很久，一直没有很充裕的时间来回忆和总结这个暑假的实习（也是我太懒了），所以我准备用每天的碎片时间来对我这个暑假做一个总结。</p>
<h1 id="实习">实习</h1>
<p>在这个暑假我找到我的第一份<code>实习</code>，也是托关系找来的，在暑假前我一直在刷脉脉和知乎，我也是被网上的言论给影响了，当时我一直有股信念，本科能找到不错的工作就没有必要读研了，特别是像现在这样的经济形势，说不定读三年研究生出来能找到的工作还不如本科时候找到的，所以我在暑假就很想学<code>技术</code>，就推掉了数模国赛转而去实习。</p>
<h2 id="七月">七月</h2>
<p>在七月十号左右我入职了，当时我的<code>mentor</code>还没来，就把显示器插排什么的都放到工位，本来以为我是来做大数据相关工作的，所以就把各类db软件下载了下来，然后开始学习</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/IMG_2957.jpeg" alt="IMG_2957" style="zoom: 50%;" /></p>
<p>第二天公司老总和我谈了谈，我当时很迷茫的一点是要不要读研，老总和我讲了很多，说未来是人工智能的天下，并且给我配的导师是搞人工智能的，技术很厉害，让我多和他学习，而且说不建议我读研。不过我当时想，ai已经卷成这样了，很多硕士都找不到工作，搞ai还不读研那不是自寻死路吗，当然这也是当时的想法，经历的多了之后想法会不断产生变化。</p>
<h3 id="初遇mentor">初遇mentor</h3>
<p>在周五左右我第一次见到了我的mentor，看起来很和善，我们也找了个时间谈了一下，他给我介绍了人工智能目前的状况，并十分建议我读研，而且最好到国外去读（毕竟国外学习和开发的环境要自由些），他说目前公司就只有他一个人搞ai，说我来还挺高兴的，这样可以有人一起讨论，而且十分愿意教我。</p>
<p>说实话我在之前也没接触过ai，也没想过去做ai，这次实习属于是我对ai的启蒙。</p>
<h3 id="学习">学习</h3>
<p>一开始因为我对ai没什么了解，所以mentor给了我很多资料，并且让我去看<code>吴恩达的deep learning</code>，听说是英文的我还害怕了一下，等到实际在学习的时候就会发现基本上没有什么障碍，不得不说很多外国的课程是真的高质量，由浅入深、通俗易懂。</p>
<p>我花了一周时间认真看完了这门课，对神经网络有了一定的了解，也意识到人工智能底层就是数学，就是<code>高数+线性代数+概率论+统计学</code>的集合。</p>
<h2 id="八月">八月</h2>
<p>mentor和我说我来的时间其实很不巧，因为公司做事是阶段性的，在我来的期间正好公司没有什么业务拓展，所以我就只好看看公司以前的项目代码。</p>
<h3 id="e集运">e集运</h3>
<p>e集运是我接触的第一个项目，mentor很详细的给我梳理了整个项目的流程框架，在这个项目我也学到很多，像<code>Docker</code>，<code>git</code>等，我准备再之后新写一篇博客具体梳理一下这个项目。</p>
<h3 id="github">Github</h3>
<p>因为拉公司项目什么的需要用到<code>git</code>，所以我也仔细学习了一下git的相关技术，我也真正理解了<code>GitHub</code>的正确打开姿势，很遗憾我到现在才真正学会了github，以后要开始代码管理咯。</p>
<h3 id="新项目">新项目</h3>
<p>我也接触到了一些公司准备新进行的项目，通过做项目我才了解我的技术远远不够，像各种数据库的使用，我们专业将数据库这门课放到了大三下学期，我认为这是极不合理的，数据库是工作时必备的技术，所以我十分建议早点把数据库学起来。</p>
<p>新项目是语言大模型和功能调用的融合，我其实没做什么，只是一直在pull代码看其他员工是怎么写的，就只是这样我也学到了很多。</p>
<h3 id="kaggle天池">Kaggle/天池</h3>
<p>在一开始的时候mentor就跟我说，如果要短期内学到很多东西，那就去打个比赛，像他自己就在打比赛，他十分推荐我去打<code>Kaggle</code>，当时我觉得，比赛什么时候都可以打，但公司项目不是什么时候都能接触的，所以就没选择打比赛，现在开学了，我也准备打一场kaggle看看，提升自己。</p>
<h3 id="分别">分别</h3>
<p>我的实习是做到8月25号，是个周五，在周一的时候mentor兴冲冲找到我说：“来活了！他们准备在之前e集运那个项目再做拓展。”唉，还是挺可惜的，那个时候已经没有时间做了。</p>
<p>最后要分别的前一天mentor又找到我聊了聊，聊到未来的方向，我当时还是想着ai太卷了，想做java开发什么的，到现在有些改观，现在我感觉未来ai的门槛会越来越低。</p>
<h1 id="未来">未来</h1>
<p>在暑期末的时候，我爸妈带我去做了职业规划，找的是抖音上的水哥职说，也在苏州，最后也是确定要出国了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker创建Ubantu容器</title>
    <url>/2023/09/04/2023/Docker/Docker%E5%88%9B%E5%BB%BAUbantu%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>为Docker创建一个Ubantu容器</p>
</blockquote>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>今天上了<code>大数据挖掘</code>和<code>Linux程序设计</code>的第一课，发现老师都要求在电脑上搞个虚拟机方便以后的操作，所以我准备使用安装Ubantu的Docker容器来作为虚拟机使用。</p>
<h1 id="操作">操作</h1>
<h2 id="基础命令">基础命令</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [option] 镜像名 [像容器中传入的命令]</span><br></pre></td></tr></table></figure>
<h3 id="常用可选说明">常用可选说明</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span>i 表示以“交互模式”运行容器</span><br><span class="line"> <span class="operator">-</span>t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</span><br><span class="line"> <span class="comment">--name 为创建的容器命名</span></span><br><span class="line"> <span class="operator">-</span>v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个<span class="operator">-</span>v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</span><br><span class="line"> <span class="operator">-</span>d 在run后面加上<span class="operator">-</span>d参数,则会创建一个守护式容器在后台运行(这样创建容器后不 会自动登录容器，如果只加<span class="operator">-</span>i <span class="operator">-</span>t 两个参数，        创建后就会自动进去容器)。</span><br><span class="line"> <span class="operator">-</span>p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个<span class="operator">-</span>p 做多个端口映射</span><br><span class="line"> <span class="operator">-</span>e 为容器设置环境变量</span><br><span class="line"> <span class="comment">--network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同</span></span><br></pre></td></tr></table></figure>
<h3 id="交互式容器">交互式容器</h3>
<p>例如，创建一个交互式容器，并命名为myubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name=myubuntu ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>在容器中可以随意执行linux命令，就是一个ubuntu的环境，当执行exit命令退出时，该容器也随之停止</p>
<h3 id="守护式容器">守护式容器</h3>
<p>创建一个守护式容器:如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。在容器内部exit退出时，容器也不会停止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -dit --name=myubuntu2 ubuntu</span><br></pre></td></tr></table></figure>
<h3 id="进入已运行的容器">进入已运行的容器</h3>
<p>docker exec -it 容器名或容器id 进入后执行的第一个命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it myubuntu2 /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="查看容器">查看容器</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出本机正在运行的容器</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"># 列出本机所有容器，包括已经终止运行的</span><br><span class="line">docker container ls --all</span><br></pre></td></tr></table></figure>
<h3 id="停止与启动容器">停止与启动容器</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 停止一个已经在运行的容器</span><br><span class="line">docker container stop 容器名或容器id</span><br><span class="line"></span><br><span class="line"># 启动一个已经停止的容器</span><br><span class="line">docker container start 容器名或容器id</span><br><span class="line"></span><br><span class="line"># kill掉一个已经在运行的容器</span><br><span class="line">docker container kill 容器名或容器id</span><br></pre></td></tr></table></figure>
<h3 id="删除容器">删除容器</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container rm 容器名或容器id</span><br></pre></td></tr></table></figure>
<h3 id="将容器保存为镜像">将容器保存为镜像</h3>
<p>我们可以通过如下命令将容器保存为镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit 容器名 镜像名</span><br></pre></td></tr></table></figure>
<h3 id="镜像备份与迁移">镜像备份与迁移</h3>
<p>我们可以通过save命令将镜像打包成文件，拷贝给别人使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save -o 保存的文件名 镜像名</span><br></pre></td></tr></table></figure>
<p>如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save -o ./ubuntu.tar ubuntu</span><br></pre></td></tr></table></figure>
<p>在拿到镜像文件后，可以通过load方法，将镜像加载到本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker load -i ./ubuntu.tar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub成就徽章全攻略（GitHub Achievements）</title>
    <url>/2023/09/08/2023/GitHub%E6%88%90%E5%B0%B1%E5%BE%BD%E7%AB%A0%E5%85%A8%E6%94%BB%E7%95%A5%EF%BC%88GitHub-Achievements%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>将各种资料整理了一下</p>
</blockquote>
<span id="more"></span>
<h2 id="成就列表">成就列表</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">徽章</th>
<th style="text-align: center;">名称</th>
<th style="text-align: center;">获取方式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/849459ac06f88476872e568dd15038ff92463b56b6c1d881eba4768c3c99f952/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f68656172742d6f6e2d796f75722d736c656576652d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/849459ac06f88476872e568dd15038ff92463b56b6c1d881eba4768c3c99f952/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f68656172742d6f6e2d796f75722d736c656576652d64656661756c742e706e67"
alt="Achievement badge Heart On Your Sleeve" /></a></td>
<td style="text-align: center;"><strong>Heart On Your
Sleeve</strong><br /><strong>（真情流露）</strong></td>
<td style="text-align: center;">用❤️表情符号对GitHub上的一些事情做出反应
<br /><strong>(测试中)</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/52c99599bf3ab70e329e1bdadc0fe81be0ec027fce4ec29e1ba77d4cae3ec38e/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6f70656e2d736f757263657265722d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/52c99599bf3ab70e329e1bdadc0fe81be0ec027fce4ec29e1ba77d4cae3ec38e/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6f70656e2d736f757263657265722d64656661756c742e706e67"
alt="Achievement badge Open Sourcerer" /></a></td>
<td style="text-align: center;"><strong>Open
Sourcerer</strong><br /><strong>（开放搜索）</strong></td>
<td style="text-align: center;">用户将PRs合并到多个公开仓库中
<br /><strong>(测试中)</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/98e693d243cde46579166501d14a9259daa92de146d9ba7d6af25255c4707974/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/98e693d243cde46579166501d14a9259daa92de146d9ba7d6af25255c4707974/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742e706e67"
alt="Achievement badge Starstruck" /></a></td>
<td
style="text-align: center;"><strong>Starstruck</strong><br /><strong>（追星族）</strong></td>
<td style="text-align: center;">个人项目取得 <strong>16
stars</strong>及以上</td>
</tr>
<tr class="even">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/f1609e8e2b3083f5210bbf4a81dc33a2b31cfd964f256caddfcfe278a702b420/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/f1609e8e2b3083f5210bbf4a81dc33a2b31cfd964f256caddfcfe278a702b420/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742e706e67"
alt="Achievement badge Quickdraw" /></a></td>
<td
style="text-align: center;"><strong>Quickdraw</strong><br /><strong>(速成)</strong></td>
<td style="text-align: center;">提交 <strong>issue / PR</strong> 并在
<strong>5 分钟</strong> 之内关掉</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/93a470d9cb4e7f8116d53a6f6e9a75c57d0359af59d8efa0b966ec11099db35f/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f706169722d65787472616f7264696e616972652d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/93a470d9cb4e7f8116d53a6f6e9a75c57d0359af59d8efa0b966ec11099db35f/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f706169722d65787472616f7264696e616972652d64656661756c742e706e67"
alt="Achievement badge Pair Extraordinaire" /></a></td>
<td style="text-align: center;"><strong>Pair
Extraordinaire</strong><br /><strong>（优秀配对）</strong></td>
<td style="text-align: center;">在一次 <strong>PR (pull
Request)</strong> 中与别人共同提交</td>
</tr>
<tr class="even">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/d4a52cfb3181d13b7a8267394f66299c39d3c9c1da254f6beea092af1c755cca/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f70756c6c2d736861726b2d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/d4a52cfb3181d13b7a8267394f66299c39d3c9c1da254f6beea092af1c755cca/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f70756c6c2d736861726b2d64656661756c742e706e67"
alt="Achievement badge Pull Shark" /></a></td>
<td style="text-align: center;"><strong>Pull
Shark</strong><br /><strong>（鲨鱼拉拉）</strong></td>
<td style="text-align: center;">提交的 <strong>PR</strong> 被兼并
<strong>2</strong> 次及以上</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/e6ce6ebed3ad198195acd59354be6eca03cc9568f9ce27db365b1504bb92e123/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f67616c6178792d627261696e2d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/e6ce6ebed3ad198195acd59354be6eca03cc9568f9ce27db365b1504bb92e123/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f67616c6178792d627261696e2d64656661756c742e706e67"
alt="Achievement badge Galaxy Brain" /></a></td>
<td style="text-align: center;"><strong>Galaxy
Brain</strong><br /><strong>（银河之脑）</strong></td>
<td
style="text-align: center;">回复别人的<strong>discussion</strong>并被<strong>mark</strong>为答案<strong>2</strong>次</td>
</tr>
<tr class="even">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/988603b9bc6683c1728f665e6c97539f6a3d7c7cced12c72c81731e7deb0398f/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f796f6c6f2d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/988603b9bc6683c1728f665e6c97539f6a3d7c7cced12c72c81731e7deb0398f/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f796f6c6f2d64656661756c742e706e67"
alt="Achievement badge YOLO" /></a></td>
<td
style="text-align: center;"><strong>YOLO</strong><br /><strong>（大胆去做）</strong></td>
<td
style="text-align: center;"><strong>Merge</strong>未经审查的<strong>PR</strong>
（耻辱之章🤣）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/84493db1ea8f017b17254903b5a4e01bf621a7e235413dd4e8ec7ca2b2b494a3/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7075626c69632d73706f6e736f722d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/84493db1ea8f017b17254903b5a4e01bf621a7e235413dd4e8ec7ca2b2b494a3/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7075626c69632d73706f6e736f722d64656661756c742e706e67"
alt="Achievement badge Public Sponsor" /></a></td>
<td style="text-align: center;"><strong>Public
Sponsor</strong><br /><strong>（公共赞助商）</strong></td>
<td style="text-align: center;">通过 <a
href="https://github.com/sponsors">GitHub Sponsors</a>赞助开源工作</td>
</tr>
<tr class="even">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/50545617a2406472c9425cae4c9b5d20fd0da3f43a658c889bb4082e1b5a1e8b/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6d6172732d323032302d636f6e7472696275746f722d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/50545617a2406472c9425cae4c9b5d20fd0da3f43a658c889bb4082e1b5a1e8b/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6d6172732d323032302d636f6e7472696275746f722d64656661756c742e706e67"
alt="Achievement badge Mars 2020 Contributor" /></a></td>
<td style="text-align: center;"><strong>Mars 2020
Contributor</strong><br /><strong>（2020火星计划贡献者）</strong></td>
<td style="text-align: center;">为 <a
href="https://github.com/readme/featured/nasa-ingenuity-helicopter">Mars
2020 Helicopter Mission</a>贡献代码<br /><strong>（绝版）</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/87254f3e7cbfae66011faddb066d019e7dc77f286e4a8286a55cad7d2c81b449/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6172637469632d636f64652d7661756c742d636f6e7472696275746f722d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/87254f3e7cbfae66011faddb066d019e7dc77f286e4a8286a55cad7d2c81b449/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6172637469632d636f64652d7661756c742d636f6e7472696275746f722d64656661756c742e706e67"
alt="Achievement badge 2020 GitHub Archive Program" /></a></td>
<td style="text-align: center;"><strong>Arctic Code Vault
Contributor</strong><br /><strong>（北极代码贡献者）</strong></td>
<td style="text-align: center;">为 <a
href="https://archiveprogram.github.com/">2020 GitHub Archive
Program</a>贡献代码<br /><strong>（绝版）</strong></td>
</tr>
</tbody>
</table>
<h2 id="徽章等级">徽章等级</h2>
<p>一些徽章可以提升等级，不同等级有不同的图案</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">成就</th>
<th style="text-align: center;">默认</th>
<th style="text-align: center;">铜</th>
<th style="text-align: center;">银</th>
<th style="text-align: center;">金</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><strong>Starstruck</strong><br /><strong>（追星族）</strong></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/98e693d243cde46579166501d14a9259daa92de146d9ba7d6af25255c4707974/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/98e693d243cde46579166501d14a9259daa92de146d9ba7d6af25255c4707974/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742e706e67"
alt="Achievement badge Starstruck" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/16bdb4fe26890a63d9b9e7dddf91b5b9412f1739536491064ec8a93bb22a9566/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d62726f6e7a652e706e67"><img
src="https://camo.githubusercontent.com/16bdb4fe26890a63d9b9e7dddf91b5b9412f1739536491064ec8a93bb22a9566/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d62726f6e7a652e706e67"
alt="Bronze badge Starstruck" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/77926f1d9649767505abef5a38570dd034baa8b53b37c793cbe1859462cd2eb8/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d73696c7665722e706e67"><img
src="https://camo.githubusercontent.com/77926f1d9649767505abef5a38570dd034baa8b53b37c793cbe1859462cd2eb8/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d73696c7665722e706e67"
alt="Silver badge Starstruck" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/b229590b555b870fdef6df68f89685248ac4b11b0c99303c01dc3eb73d91a3c1/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d676f6c642e706e67"><img
src="https://camo.githubusercontent.com/b229590b555b870fdef6df68f89685248ac4b11b0c99303c01dc3eb73d91a3c1/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d676f6c642e706e67"
alt="Gold badge Starstruck" /></a></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">16 stars</td>
<td style="text-align: center;">128 stars</td>
<td style="text-align: center;">512 stars</td>
<td style="text-align: center;">4096 stars</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Pair
Extraordinaire</strong><br /><strong>（优秀配对）</strong></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/93a470d9cb4e7f8116d53a6f6e9a75c57d0359af59d8efa0b966ec11099db35f/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f706169722d65787472616f7264696e616972652d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/93a470d9cb4e7f8116d53a6f6e9a75c57d0359af59d8efa0b966ec11099db35f/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f706169722d65787472616f7264696e616972652d64656661756c742e706e67"
alt="Achievement badge Pair Extraordinaire" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/9021c7148e9a63787fe02e923bbda4bbaa2c2693ecf182950fdaf3f372781e90/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f706169722d65787472616f7264696e616972652d62726f6e7a652e706e67"><img
src="https://camo.githubusercontent.com/9021c7148e9a63787fe02e923bbda4bbaa2c2693ecf182950fdaf3f372781e90/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f706169722d65787472616f7264696e616972652d62726f6e7a652e706e67"
alt="Bronze badge Pair Extraordinaire" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/3a627e47c3de6a2a35f6b7568f59593ca62c3079a5fba6d35da10a319a02b752/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f706169722d65787472616f7264696e616972652d73696c7665722e706e67"><img
src="https://camo.githubusercontent.com/3a627e47c3de6a2a35f6b7568f59593ca62c3079a5fba6d35da10a319a02b752/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f706169722d65787472616f7264696e616972652d73696c7665722e706e67"
alt="Silver badge Pair Extraordinaire" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/283629e271c7ac1eb4e1be65627ebb9a7d6f9e0867e86c94c91bf32eb08940ad/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f706169722d65787472616f7264696e616972652d676f6c642e706e67"><img
src="https://camo.githubusercontent.com/283629e271c7ac1eb4e1be65627ebb9a7d6f9e0867e86c94c91bf32eb08940ad/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f706169722d65787472616f7264696e616972652d676f6c642e706e67"
alt="Gold badge Pair Extraordinaire" /></a></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">1 pull requests</td>
<td style="text-align: center;">10 pull requests</td>
<td style="text-align: center;">24 pull requests</td>
<td style="text-align: center;">48 pull requests</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Pull
Shark</strong><br /><strong>（鲨鱼拉拉）</strong></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/d4a52cfb3181d13b7a8267394f66299c39d3c9c1da254f6beea092af1c755cca/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f70756c6c2d736861726b2d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/d4a52cfb3181d13b7a8267394f66299c39d3c9c1da254f6beea092af1c755cca/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f70756c6c2d736861726b2d64656661756c742e706e67"
alt="Achievement badge Pull Shark" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/dd1a16203414cfce058a25d1a3a66a49bb5be45012a8b7fb82652ad3328378bf/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f70756c6c2d736861726b2d62726f6e7a652e706e67"><img
src="https://camo.githubusercontent.com/dd1a16203414cfce058a25d1a3a66a49bb5be45012a8b7fb82652ad3328378bf/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f70756c6c2d736861726b2d62726f6e7a652e706e67"
alt="Bronze badge Pull Shark" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/4213d091e09c46ba8729bc085b9eefc815d516a09e02c90c22c6a8e5eedb0f80/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f70756c6c2d736861726b2d73696c7665722e706e67"><img
src="https://camo.githubusercontent.com/4213d091e09c46ba8729bc085b9eefc815d516a09e02c90c22c6a8e5eedb0f80/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f70756c6c2d736861726b2d73696c7665722e706e67"
alt="Silver badge Pull Shark" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/5bd00fa9303c0eff492cb247f636dde135bd729946fda4db71969b72aa74e076/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f70756c6c2d736861726b2d676f6c642e706e67"><img
src="https://camo.githubusercontent.com/5bd00fa9303c0eff492cb247f636dde135bd729946fda4db71969b72aa74e076/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f70756c6c2d736861726b2d676f6c642e706e67"
alt="Gold badge Pull Shark" /></a></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">2 pull requests</td>
<td style="text-align: center;">16 pull requests</td>
<td style="text-align: center;">128 pull requests</td>
<td style="text-align: center;">1024 pull requests</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Galaxy
Brain</strong><br /><strong>（银河之脑）</strong></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/e6ce6ebed3ad198195acd59354be6eca03cc9568f9ce27db365b1504bb92e123/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f67616c6178792d627261696e2d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/e6ce6ebed3ad198195acd59354be6eca03cc9568f9ce27db365b1504bb92e123/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f67616c6178792d627261696e2d64656661756c742e706e67"
alt="Achievement badge Galaxy Brain" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/25524aaa1ecffdc244058957db8191eee86d7ca30392829e5239b52d8b6400b7/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f67616c6178792d627261696e2d62726f6e7a652e706e67"><img
src="https://camo.githubusercontent.com/25524aaa1ecffdc244058957db8191eee86d7ca30392829e5239b52d8b6400b7/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f67616c6178792d627261696e2d62726f6e7a652e706e67"
alt="Bronze badge Galaxy Brain" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/b48c2481d0974d6c1c836bf27885549464a8535f71c28b9c9cd40a73697f5bd5/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f67616c6178792d627261696e2d73696c7665722e706e67"><img
src="https://camo.githubusercontent.com/b48c2481d0974d6c1c836bf27885549464a8535f71c28b9c9cd40a73697f5bd5/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f67616c6178792d627261696e2d73696c7665722e706e67"
alt="Silver badge Galaxy Brain" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/670c92db3207068024ad02f0327a1974fd5c8226304b4c3a6faccaf263a5361f/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f67616c6178792d627261696e2d676f6c642e706e67"><img
src="https://camo.githubusercontent.com/670c92db3207068024ad02f0327a1974fd5c8226304b4c3a6faccaf263a5361f/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f67616c6178792d627261696e2d676f6c642e706e67"
alt="Gold badge Galaxy Brain" /></a></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">2 answers</td>
<td style="text-align: center;">8 answers</td>
<td style="text-align: center;">16 answers</td>
<td style="text-align: center;">32 answers</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Heart On Your
Sleeve</strong><br /><strong>（真情流露）</strong></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/849459ac06f88476872e568dd15038ff92463b56b6c1d881eba4768c3c99f952/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f68656172742d6f6e2d796f75722d736c656576652d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/849459ac06f88476872e568dd15038ff92463b56b6c1d881eba4768c3c99f952/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f68656172742d6f6e2d796f75722d736c656576652d64656661756c742e706e67"
alt="Achievement badge Heart On Your Sleeve" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/cee7d1fb05831953ff5b74952a71bcf0bf18c4cbddc18fa0b4b32e52e01b4bf6/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f68656172742d6f6e2d796f75722d736c656576652d62726f6e7a652e706e67"><img
src="https://camo.githubusercontent.com/cee7d1fb05831953ff5b74952a71bcf0bf18c4cbddc18fa0b4b32e52e01b4bf6/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f68656172742d6f6e2d796f75722d736c656576652d62726f6e7a652e706e67"
alt="Bronze badge Heart On Your Sleeve" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/326a859ff23caa577676ed750a85d083381d415f6304faa79408976f979e0d9b/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f68656172742d6f6e2d796f75722d736c656576652d73696c7665722e706e67"><img
src="https://camo.githubusercontent.com/326a859ff23caa577676ed750a85d083381d415f6304faa79408976f979e0d9b/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f68656172742d6f6e2d796f75722d736c656576652d73696c7665722e706e67"
alt="Silver badge Heart On Your Sleeve" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/28e81dd97098bd8b31dfdd5901ff4e9d99d889baf6fe2910201d02f4a89077f3/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f68656172742d6f6e2d796f75722d736c656576652d676f6c642e706e67"><img
src="https://camo.githubusercontent.com/28e81dd97098bd8b31dfdd5901ff4e9d99d889baf6fe2910201d02f4a89077f3/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f68656172742d6f6e2d796f75722d736c656576652d676f6c642e706e67"
alt="Gold badge Heart On Your Sleeve" /></a></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">???</td>
<td style="text-align: center;">???</td>
<td style="text-align: center;">???</td>
<td style="text-align: center;">???</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Open
Sourcerer</strong><br /><strong>（开放搜索）</strong></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/52c99599bf3ab70e329e1bdadc0fe81be0ec027fce4ec29e1ba77d4cae3ec38e/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6f70656e2d736f757263657265722d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/52c99599bf3ab70e329e1bdadc0fe81be0ec027fce4ec29e1ba77d4cae3ec38e/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6f70656e2d736f757263657265722d64656661756c742e706e67"
alt="Achievement badge Open Sourcerer" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/a299c8e212b0838191281400a176e0d34df873f4c7b0275e6ca958f73c11e6c4/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6f70656e2d736f757263657265722d62726f6e7a652e706e67"><img
src="https://camo.githubusercontent.com/a299c8e212b0838191281400a176e0d34df873f4c7b0275e6ca958f73c11e6c4/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6f70656e2d736f757263657265722d62726f6e7a652e706e67"
alt="Bronze badge Open Sourcerer" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/5de4cc7d7eeea80d20b9384313e4034f438c92aca079f2f04eefc46ae6cbc967/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6f70656e2d736f757263657265722d73696c7665722e706e67"><img
src="https://camo.githubusercontent.com/5de4cc7d7eeea80d20b9384313e4034f438c92aca079f2f04eefc46ae6cbc967/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6f70656e2d736f757263657265722d73696c7665722e706e67"
alt="Silver badge Open Sourcerer" /></a></td>
<td style="text-align: center;"><a
href="https://camo.githubusercontent.com/1be237d8628c5db6d24211f4205c300522d1eaecdb3d6ab5c3bf3e67527007cf/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6f70656e2d736f757263657265722d676f6c642e706e67"><img
src="https://camo.githubusercontent.com/1be237d8628c5db6d24211f4205c300522d1eaecdb3d6ab5c3bf3e67527007cf/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f6f70656e2d736f757263657265722d676f6c642e706e67"
alt="Gold badge Open Sourcerer" /></a></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">???</td>
<td style="text-align: center;">???</td>
<td style="text-align: center;">???</td>
<td style="text-align: center;">???</td>
</tr>
</tbody>
</table>
<h2 id="徽章皮肤">徽章皮肤</h2>
<p>一些成就的外观取决于你的<strong>表情符号</strong>肤色偏好</p>
<p>你可以在 <a href="https://github.com/settings/appearance">appearance
settings</a>修改你的偏好</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>徽章</strong></th>
<th>👋</th>
<th>👋🏻</th>
<th>👋🏼</th>
<th>👋🏽</th>
<th>👋🏾</th>
<th>👋🏿</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Starstruck</strong><br /><strong>（追星族）</strong></td>
<td><a
href="https://camo.githubusercontent.com/98e693d243cde46579166501d14a9259daa92de146d9ba7d6af25255c4707974/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/98e693d243cde46579166501d14a9259daa92de146d9ba7d6af25255c4707974/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742e706e67"
alt="Default skin tone of Starstruck" /></a></td>
<td><a
href="https://camo.githubusercontent.com/7f5af5adb497a801ddc9ad6ba8b1bf16a487cf46fb2dd7651a8188383d041697/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742d2d6c696768742e706e67"><img
src="https://camo.githubusercontent.com/7f5af5adb497a801ddc9ad6ba8b1bf16a487cf46fb2dd7651a8188383d041697/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742d2d6c696768742e706e67"
alt="Light skin tone of Starstruck" /></a></td>
<td><a
href="https://camo.githubusercontent.com/26ed2e3356c3268e51f04ae88c88818fa2d77bec49b5f36e17fec2570b473a53/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742d2d6c696768742d6d656469756d2e706e67"><img
src="https://camo.githubusercontent.com/26ed2e3356c3268e51f04ae88c88818fa2d77bec49b5f36e17fec2570b473a53/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742d2d6c696768742d6d656469756d2e706e67"
alt="Light-medium skin tone of Starstruck" /></a></td>
<td><a
href="https://camo.githubusercontent.com/0ef6b3bf8ad252138e20ebfe6e7e60a95fc5dbe6648f6fc364069758ef42e66c/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742d2d6d656469756d2e706e67"><img
src="https://camo.githubusercontent.com/0ef6b3bf8ad252138e20ebfe6e7e60a95fc5dbe6648f6fc364069758ef42e66c/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742d2d6d656469756d2e706e67"
alt="Medium skin tone of Starstruck" /></a></td>
<td><a
href="https://camo.githubusercontent.com/f6e8547bd35aa3af75753edd38a6add5e08da08c58e56a725d75a9f3447e30b6/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742d2d6d656469756d2d6461726b2e706e67"><img
src="https://camo.githubusercontent.com/f6e8547bd35aa3af75753edd38a6add5e08da08c58e56a725d75a9f3447e30b6/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742d2d6d656469756d2d6461726b2e706e67"
alt="Medium-dark skin tone of Starstruck" /></a></td>
<td><a
href="https://camo.githubusercontent.com/8f121e9fbc3ca6cb2da99f2c1169c8d0aa0b458194c727ef707af7d02d2fbb8c/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742d2d6461726b2e706e67"><img
src="https://camo.githubusercontent.com/8f121e9fbc3ca6cb2da99f2c1169c8d0aa0b458194c727ef707af7d02d2fbb8c/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f7374617273747275636b2d64656661756c742d2d6461726b2e706e67"
alt="Dark skin tone of Starstruck" /></a></td>
</tr>
<tr class="even">
<td><strong>Quickdraw</strong><br /><strong>（速成）</strong></td>
<td><a
href="https://camo.githubusercontent.com/f1609e8e2b3083f5210bbf4a81dc33a2b31cfd964f256caddfcfe278a702b420/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742e706e67"><img
src="https://camo.githubusercontent.com/f1609e8e2b3083f5210bbf4a81dc33a2b31cfd964f256caddfcfe278a702b420/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742e706e67"
alt="Default skin tone of Quickdraw" /></a></td>
<td><a
href="https://camo.githubusercontent.com/1d62914a828cfaab99381c00bc8a9b41929f48b5ef02fdf69b62248cb828ec9c/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742d2d6c696768742e706e67"><img
src="https://camo.githubusercontent.com/1d62914a828cfaab99381c00bc8a9b41929f48b5ef02fdf69b62248cb828ec9c/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742d2d6c696768742e706e67"
alt="Light skin tone of Quickdraw" /></a></td>
<td><a
href="https://camo.githubusercontent.com/676a12013829d69ab7732d6cf744012447da573efcd980c2adad92906d88d371/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742d2d6c696768742d6d656469756d2e706e67"><img
src="https://camo.githubusercontent.com/676a12013829d69ab7732d6cf744012447da573efcd980c2adad92906d88d371/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742d2d6c696768742d6d656469756d2e706e67"
alt="Light-medium skin tone of Quickdraw" /></a></td>
<td><a
href="https://camo.githubusercontent.com/8503450b76d881d6fc122cb4840e01e19f7fb2edc964cc6abf13940b44a92eb7/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742d2d6d656469756d2e706e67"><img
src="https://camo.githubusercontent.com/8503450b76d881d6fc122cb4840e01e19f7fb2edc964cc6abf13940b44a92eb7/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742d2d6d656469756d2e706e67"
alt="Medium skin tone of Quickdraw" /></a></td>
<td><a
href="https://camo.githubusercontent.com/94f6732d580f5ce8e6043535a5fdd3902465d3afa80c72850e2e9702f5672cb8/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742d2d6d656469756d2d6461726b2e706e67"><img
src="https://camo.githubusercontent.com/94f6732d580f5ce8e6043535a5fdd3902465d3afa80c72850e2e9702f5672cb8/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742d2d6d656469756d2d6461726b2e706e67"
alt="Medium-dark skin tone of Quickdraw" /></a></td>
<td><a
href="https://camo.githubusercontent.com/8e9f3e39ae34c0a035fb98c68483ce259d342669692db76fc35907e6b84e9748/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742d2d6461726b2e706e67"><img
src="https://camo.githubusercontent.com/8e9f3e39ae34c0a035fb98c68483ce259d342669692db76fc35907e6b84e9748/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f696d616765732f6d6f64756c65732f70726f66696c652f616368696576656d656e74732f717569636b647261772d64656661756c742d2d6461726b2e706e67"
alt="Dark skin tone of Quickdraw" /></a></td>
</tr>
</tbody>
</table>
<blockquote>
<p>参考资料：</p>
<p>https://github.com/github-profile-achievements/english</p>
<p>https://www.6hu.cc/archives/59570.html</p>
<p>https://github.com/jhonywalkeer/github-achivements</p>
</blockquote>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu配置hadoop（基于Docker）</title>
    <url>/2023/09/07/2023/Docker/Ubuntu%E9%85%8D%E7%BD%AEhadoop%EF%BC%88%E5%9F%BA%E4%BA%8EDocker%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>大数据挖掘需要搭建Linux虚拟机上的hadoop集群</p>
<p>踩过的坑都在这里了</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p><strong>前言</strong></p>
<p>在大数据挖掘和Linux这两门课都需要搭建Linux环境，老师的推荐都是VMware等虚拟机，我觉得用Docker容器更加方便一些，于是就找教程用Docker创建Ubuntu容器，但是踩了很多坑，还好都解决了，现在记录一下。</p>
</blockquote>
<h1 id="一启动docker容器">一、启动Docker容器</h1>
<p>首先pull一个Ubuntu镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这边直接pull
ubuntu的话会直接下载最新版本，可以通过ubuntu:18.04来下载指定版本</p>
</blockquote>
<p>接着通过镜像运行一个容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -dit --name=main -p 9870:9870 -p 8088:8088 ubuntu</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里要使用-p指令开放9870和8088两个端口，之后会用到</p>
</blockquote>
<p>使用docker exec命令进入容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it main /bin/bash</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230907221648062.png"
alt="image-20230907221648062" />
<figcaption aria-hidden="true">image-20230907221648062</figcaption>
</figure>
<h1 id="二安装jdk">二、安装jdk</h1>
<p>在<code>Ubuntu</code>中用压缩包安装jdk较为麻烦，需要<code>配置系统环境变量</code>和<code>配置文件</code>，一步出错可能无法使用。所以本文在<code>Ubuntu</code>中使用命令安装jdk。其他方法安装jdk也可。</p>
<p>打开终端</p>
<p>执行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230907201605154.png" alt="image-20230907201605154" style="zoom: 50%;" /></p>
<blockquote>
<p>如果报错bash: sudo: command not found的话，先执行下面两个命令</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get update <span class="comment"># 更新apt-get</span></span><br><span class="line">apt-get install sudo <span class="comment"># 安装sudo</span></span><br></pre></td></tr></table></figure>
<p>安装完成后查看Java是否安装成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p>如下图所示则安装成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230907201808967.png" alt="image-20230907201808967" style="zoom: 80%;" /></p>
<p>如果需要卸载jdk则使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt remove openjdk*</span><br></pre></td></tr></table></figure>
<h1 id="三配置环境文件">三、配置环境文件</h1>
<h2 id="打开环境文件">打开环境文件</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>如果没有vim编辑器则需要下载：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>
<p>或使用gedit编辑器也行</p>
<h2 id="加入语句">加入语句</h2>
<p>文件顶部加入以下语句并保存：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 <span class="comment">#目录要换成自己jdk所在目录</span></span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre  </span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib  </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span> </span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230907224228576.png" alt="image-20230907224228576" style="zoom:67%;" /></p>
<p>使环境生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>使用 <code>echo $JAVA_HOME</code>
显示<code>JAVA_HOME</code>即为成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230907224430938.png" alt="image-20230907224430938"  /></p>
<h1 id="四安装ssh免密码登录">四、安装ssh免密码登录</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ssh openssh-server</span><br></pre></td></tr></table></figure>
<p>安装完毕后先cd到~</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure>
<p>再创建.ssh文件夹</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .ssh</span><br></pre></td></tr></table></figure>
<p>再cd到.ssh中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> .ssh</span><br></pre></td></tr></table></figure>
<p>生成密钥</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa </span><br></pre></td></tr></table></figure>
<p>按三次回车</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230907230349029.png" alt="image-20230907230349029" style="zoom: 80%;" /></p>
<p>将秘钥加入到授权中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>
<p>再验证ssh localhost 如下图，不用密码登录即为成功</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230907230905985.png"
alt="image-20230907230905985" />
<figcaption aria-hidden="true">image-20230907230905985</figcaption>
</figure>
<blockquote>
<p>如果发生以下报错，那就看这个博客的解决方案 <a
href="https://blog.csdn.net/wfx056012/article/details/115707777">这里</a>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230907231020690.png"
alt="image-20230907231020690" /></p>
</blockquote>
<h1 id="五安装hadoop">五、安装Hadoop</h1>
<p>1）安装hadoop并解压</p>
<p>先cd到/usr/local</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local</span><br></pre></td></tr></table></figure>
<p>镜像下载链接https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.3.1/</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.3.1/hadoop-3.3.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>然后解压后进入文件夹</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf hadoop-3.3.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> hadoop-3.3.1</span><br></pre></td></tr></table></figure>
<p>2）配置相关文件</p>
<blockquote>
<p>core-site.xml</p>
</blockquote>
<p>打开/etc/hadoop中的core-site.xml 文件，加入如下语句并保存</p>
<blockquote>
<p>注意在在<code>configuration</code>标签中加入</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">             &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">             &lt;value&gt;file:/usr/local/hadoop-3.3.1/tmp&lt;/value&gt;</span><br><span class="line">             &lt;description&gt;Abase <span class="keyword">for</span> other temporary directories.&lt;/description&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">             &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">             &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230907232907417.png" alt="image-20230907232907417" style="zoom:80%;" /></p>
<blockquote>
<p>hdfs-site.xml</p>
</blockquote>
<p>和上面一样，打开/etc中的hdfs-site.xml 文件，加入如下语句并保存</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">             &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">             &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">             &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">             &lt;value&gt;file:/usr/local/hadoop-3.3.1/tmp/dfs/name&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">             &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">             &lt;value&gt;file:/usr/local/hadoop-3.3.1/tmp/dfs/data&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hadoop-env.sh</p>
</blockquote>
<p>查看你的 jdk安装目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br></pre></td></tr></table></figure>
<p>打开 hadoop-env.sh 文件配置如下并保存：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="string">&quot;/usr/lib/jvm/java-8-openjdk-amd64&quot;</span>  <span class="comment"># 根据自己的路径写</span></span><br></pre></td></tr></table></figure>
<h1 id="六运行hadoop">六、运行Hadoop</h1>
<p>1）首先初始化HDFS系统</p>
<p>在hadop3.3.0目录下使用如下命令进行初始化：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br></pre></td></tr></table></figure>
<p>成功后如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230908100159505.png" alt="image-20230908100159505" style="zoom: 67%;" /></p>
<p>2）开启NameNode和DataNode守护进程</p>
<p>继续运行如下命令开启Hadoop：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure>
<p>成功后如下图：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230908100504572.png"
alt="image-20230908100504572" />
<figcaption aria-hidden="true">image-20230908100504572</figcaption>
</figure>
<blockquote>
<p>如果出现以下报错，请查看这个博客 <a
href="https://blog.csdn.net/emgexgb_sef/article/details/124246231">这里</a></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230908100616153.png"
alt="image-20230908100616153" />
<figcaption aria-hidden="true">image-20230908100616153</figcaption>
</figure>
</blockquote>
<p>3）查看jps进程信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>
<p>如下图即为成功： <img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230908101222750.png"
alt="image-20230908101222750" /></p>
<blockquote>
<p>关闭hadoop使用命令 sbin/stop-dfs.sh</p>
</blockquote>
<p>打开浏览器输入<a
href="http://localhost:9870/">http://localhost:9870</a>，成功打开</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230908101314185.png" alt="image-20230908101314185" style="zoom:67%;" /></p>
<p>4）创建Hadoop用户组</p>
<p>使用/bin/bash作为shell：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo useradd -m hadoop -s /bin/bash </span><br></pre></td></tr></table></figure>
<p>设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo passwd hadoop</span><br></pre></td></tr></table></figure>
<p>添加hadoop至管理员权限：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo adduser hadoop sudo</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230908102449452.png" alt="image-20230908102449452" style="zoom:80%;" /></p>
<h1 id="七配置yarn">七、配置yarn</h1>
<blockquote>
<p>搭建前请保证已经搭建好了HDFS的环境，即配置好所上内容。</p>
</blockquote>
<p>1）终端输入hostname查看主机名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure>
<p>2）打开/etc/hadoop下yarn-site.xml，在<code>configuration</code>标签中加入如下内容，注意主机名要修改为自己的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!--Resource Manager--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;你的主机名&lt;/value&gt;&lt;!--你的hostname的主机名--&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p>3）打开mapred-site.xml
文件，配置如下（在configuration标签中间加入）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p>4）在主文件夹输入命令启动yarn</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>
<p>jps查看进程多了两个东西</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230908103109094.png" alt="image-20230908103109094"  /></p>
<p>在浏览器输入http://localhost:8088</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230908103241262.png" alt="image-20230908103241262" style="zoom:80%;" /></p>
<p>至此，hadoop全部配置完成</p>
<h1 id="创建镜像">创建镜像</h1>
<p>为了后期使用方便，我们可以将容器保存为镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker commit main hadoop_base</span><br></pre></td></tr></table></figure>
<p>这样我们想要启动一个新的容器时只需要在镜像上启动就行了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -dit -p 9870:9870 -p 8088:8088 main hadoop_base</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：</p>
<p>https://blog.csdn.net/weixin_58707437/article/details/127931069</p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Docker搭建完全分布式Hadoop集群</title>
    <url>/2023/09/19/2023/Docker/%E9%80%9A%E8%BF%87Docker%E6%90%AD%E5%BB%BA%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8FHadoop%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<blockquote>
<p>基于上一篇博客进行拓展</p>
</blockquote>
<span id="more"></span>
<h1 id="前言">前言</h1>
<blockquote>
<p><a
href="https://www.justinchoi.top/2023/09/07/2023/Ubuntu%E9%85%8D%E7%BD%AEhadoop%EF%BC%88%E5%9F%BA%E4%BA%8EDocker%EF%BC%89/">上一次</a>我们搭建了基于Docker的伪分布式Hadoop集群，这次来搭建分布式的</p>
</blockquote>
<h1 id="一为集群单独构建虚拟网络">一、为集群单独构建虚拟网络</h1>
<p>现在的 Docker 网络能够提供 DNS
解析功能，我们可以使用如下命令为接下来的 Hadoop
集群单独构建一个虚拟的网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker network create --driver=bridge hadoop</span><br></pre></td></tr></table></figure>
<p>使用下面这个命令查看 Docker 中的网络，可以看到刚刚创建的名为 hadoop
的虚拟桥接网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker network ls</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309201145415.png" alt="image-20230919201453731" style="zoom: 67%;" /></p>
<h1 id="二进入上次搭建好的容器">二、进入上次搭建好的容器</h1>
<p>我们通过上次制作的镜像启动一个容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit --name=master --hostname=master hdp</span><br></pre></td></tr></table></figure>
<p>我们进入<code>master</code>容器中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it master /bin/bash</span><br></pre></td></tr></table></figure>
<h1 id="三配置hadoop环境">三、配置Hadoop环境</h1>
<p>在上一次我们已经配置了一个伪分布式的Hadoop环境，接下来我们需要对那些文件再进一步修改。</p>
<h2 id="修改core-site.xml">1.修改<code>core-site.xml</code></h2>
<p>打开<code>/usr/local/hadoop-3.3.1/etc/hadoop</code>路径下的<code>core-site.xml</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/hadoop-3.3.1</span><br><span class="line">cd etc/hadoop</span><br><span class="line">vim core-site.xml</span><br></pre></td></tr></table></figure>
<p>修改后是这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">　　&lt;!--指定nameNode的地址--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://master:8020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">　　&lt;!--指定Hadoop数据的存储目录--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/usr/local/hadoop/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">　　&lt;!--配置HDFS网页登陆使用的静态用户，配置这个之后才有权限可以在网页端删除文件、文件夹--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.http.staticuser.user&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;root&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h2 id="修改hdfs-site.xml">2.修改<code>hdfs-site.xml</code></h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim hdfs-site.xml</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">　　&lt;!--文件的存储个数--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">　　&lt;!--nn web端访问地址，使用网页访问HDFS文件系统就是这个端口--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.http-address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;master:9870&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">　　&lt;!--2nn web端访问地址--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;master:9868&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">　　&lt;!--网页查看HDFS文件内容，出现Couldn‘t preview the file报错，需要配置的参数--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h2 id="修改mapred-site.xml">3.修改<code>mapred-site.xml</code></h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim mapred-site.xml</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">　　&lt;!--指定MapReduce程序运行在Yarn上--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h2 id="修改yarn-site.xml">4.修改<code>yarn-site.xml</code></h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim yarn-site.xml</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">　　&lt;!--指定MR走 shuffle--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">　　&lt;!--指定ResourceManager的地址--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;h01&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">　　&lt;!--环境变量的继承--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt;         </span><br><span class="line">        &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h2 id="修改workers">5.修改<code>workers</code></h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim workers</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：master这些后面不要有空格！slave2后面，不要有空的行！自己准备起多少集群，就在这里写几个，要是准备起5个集群，就写到slave4。</p>
</blockquote>
<h1 id="四在docker中启动集群">四、在Docker中启动集群</h1>
<h2 id="先将容器导出为镜像">1.先将容器导出为镜像</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit master nethdp</span><br></pre></td></tr></table></figure>
<h2 id="启动三个终端">2.启动三个终端</h2>
<ul>
<li><p>第一条命令启动的是<code>master</code>做<code>master</code>节点的，所以要开放一些端口，用来访问web页面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit --network hadoop --hostname=master --name=master -p 9870:9870 -p 8088:8088 nethdp /bin/bash</span><br></pre></td></tr></table></figure></li>
<li><p>后面几条命令都类似，只要注意修改名字和主机名就行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit --network hadoop -hostname=slave1 --name=slave1 nethdp /bin/bash</span><br></pre></td></tr></table></figure></li>
<li><p>第三条命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit --network hadoop -hostname=slave2 --name=slave2 nethdp /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
<h2
id="接下来在master主机中启动hadoop集群">3.接下来在<code>master</code>主机中启动Hadoop集群</h2>
<p>先在hadoop安装目录进行格式化操作，不格式化操作，hdfs起不来（<strong>只有第一次启动</strong>的时候需要初始化，以后启动就不需要了，先删除所有机器的
data和logs目录，然后再进行格式化）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309201145608.png" alt="image-20230919205754453" style="zoom:80%;" /></p>
<p>然后启动HDFS集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309201145588.png"
alt="image-20230919210507605" />
<figcaption aria-hidden="true">image-20230919210507605</figcaption>
</figure>
<p>最后，启动yarn集群管理节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>
<p>都启动完成后，使用 jps 命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309201145662.png" alt="image-20230919210554410" style="zoom:80%;" /></p>
<p>可以看到，除了Jps，一共有5个进程，因为这里没有将
nameNode、ResourceManager、SecondaryNameNode分开部署，所以都在
h01这一台机器上，实际生产中，应该是需要分开部署的。</p>
<p>至此，Hadoop 集群已经构建好了。</p>
<h1 id="五网页访问">五、网页访问</h1>
<h2 id="浏览器访问本机的9870端口">1.浏览器访问本机的9870端口</h2>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309201145278.png" alt="image-20230919210729977" style="zoom: 67%;" /></p>
<h2 id="浏览器访问本机的8088端口">2.浏览器访问本机的8088端口</h2>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309201145164.png" alt="image-20230919210811664" style="zoom:67%;" /></p>
<blockquote>
<p>参考：</p>
<p><a
href="https://www.cnblogs.com/luo-c/p/15831441.html">https://www.cnblogs.com/luo-c/p/15831441.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>优化问题笔记</title>
    <url>/2023/09/17/2023/%E6%9C%80%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>南京邮电大学课程：最优化方法——张伯雷</p>
</blockquote>
<span id="more"></span>
<h1 id="前言">前言</h1>
<blockquote>
<p>本系列笔记的图片部分来自张伯雷老师的课堂ppt和网上，笔记仅供本人和需要的人学习使用。</p>
</blockquote>
<h1 id="优化问题介绍">优化问题介绍</h1>
<h2 id="优化问题1">优化问题1</h2>
<h3 id="题目">题目</h3>
<blockquote>
<ul>
<li>还有⼀个星期就要到期末考试，小明⼀共要考4门课，但只能复习70个小时，假设<span
class="math inline">\(x=(x_1,x_2,...,x_4)\)</span>代表小明分别花在4门课上的时间</li>
<li><span class="math inline">\(f_i(x)\)</span>, 𝑖 = 1, 2, 3, 4
为小明在第𝑖门课中的成绩</li>
</ul>
</blockquote>
<h3 id="问题建模">问题建模</h3>
<ul>
<li><p>最大化最终的总分数：<span
class="math inline">\(\sum_if_i(x)\)</span></p></li>
<li><p>每门课都需要及格，同时花的时间不能超过70：</p></li>
<li><p><span class="math inline">\(\sum_ix_i ≤ 70\)</span>, <span
class="math inline">\(x_i ≥ 0\)</span>, <span
class="math inline">\(f_i(x_i) ≥ 60\)</span></p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230917224239707.png" alt="image-20230917224239707" style="zoom:67%;" /></p>
<h3 id="如何合理分配资源">如何合理分配资源？</h3>
<h2 id="优化问题2">优化问题2</h2>
<h3 id="题目-1">题目</h3>
<blockquote>
<ul>
<li>小李是⼀个程序员，需要实现⼀个数据中⼼服务，当有用户请求服务时，需要尽快地服务用户请求，来降低整体延迟</li>
<li><span class="math inline">\(d_i(x_i)=1,2,...,n\)</span></li>
<li><span
class="math inline">\(x_i\)</span>为向用户𝑖分配的资源（如CPU的配额），
<span class="math inline">\(d_i\)</span>为第𝑖个用户的延迟</li>
</ul>
</blockquote>
<h3 id="问题建模-1">问题建模</h3>
<ul>
<li><p>最小化整体的延迟：<span
class="math inline">\(\sum_id_i(x_i)\)</span></p></li>
<li><p>同时不能超过服务器的总资源：<span
class="math inline">\(\sum_ix_i\le C\)</span>, <span
class="math inline">\(x_i\ge0\)</span></p></li>
</ul>
<h3 id="如何合理分配资源-1">如何合理分配资源？</h3>
<h2 id="优化问题3">优化问题3</h2>
<h3 id="题目-2">题目</h3>
<blockquote>
<ul>
<li>现在有⼀百万张图片，⼀共分成了1000个类别𝑝，我们设计了⼀个复杂的神经⽹络，可以输入图片矩阵输出类别概率𝑞。为了训练这个神经⽹络，需要优化该网络，最小化预测误差。</li>
</ul>
</blockquote>
<h3 id="问题建模-2">问题建模</h3>
<p><span class="math display">\[
min-\sum_{x\in X} p(x)\log q(x)
\]</span></p>
<h3
id="神经网络可能包括上亿的参数如何快速优化">神经网络可能包括上亿的参数，如何快速优化？</h3>
<h2 id="优化数学规划">优化/数学规划</h2>
<h3 id="优化问题">优化问题</h3>
<p><span class="math display">\[
\min f_0(x).\\
\text{s.t.}\ \ f_i(x)\le0,\quad i=1,...,m
\]</span></p>
<blockquote>
<p>其中</p>
<ul>
<li><span
class="math inline">\(x=(x_1,x_2,...,x_n)\)</span>：优化变量(variable)</li>
<li><span class="math inline">\(f_0:
\mathbb{R}^n\rightarrow\mathbb{R}\)</span>：目标函数(Objective
function)</li>
<li><span class="math inline">\(f_i:
\mathbb{R}^n\rightarrow\mathbb{R},i=1,...m\)</span>：约束函数(Constraints)</li>
<li>最优解<span
class="math inline">\(x^*\)</span>：所有在定义域且满⾜约束条件的解中使得目标函数<span
class="math inline">\(f_0\)</span>最小的<span
class="math inline">\(x\)</span></li>
<li>最优值<span class="math inline">\(p*:f_0(x^*)\)</span></li>
</ul>
</blockquote>
<h1 id="优化问题分类">优化问题分类</h1>
<h2 id="线性非线性规划">线性/非线性规划</h2>
<h3 id="线性规划">线性规划：</h3>
<ul>
<li>如果目标函数与约束函数都是线性的，则为线性规划（Linear
programming）</li>
<li><span class="math inline">\(f_i(\alpha x+\beta y)=\alpha
f_i(x)+\beta f_i(y),i=0,1,...,m\)</span></li>
<li>单纯形法(simplex method)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453912.png" alt="image-20230918210805588" style="zoom:80%;" /></p>
<h3 id="非线性规划">非线性规划：</h3>
<ul>
<li>如果目标函数与约束函数有⼀个不是线性的，则为非线性规划（Non-Linear
programming）</li>
</ul>
<h2 id="凸非凸规划">凸/非凸规划</h2>
<h3 id="凸规划">凸规划：</h3>
<ul>
<li>可行解集是凸集，目标函数是凸函数</li>
<li><span class="math inline">\(f_i(\alpha x+\beta y)\le\alpha
f_i(x)+\beta f_i(y),i=0,1,...,m\)</span></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453003.png" alt="image-20230918211043295" style="zoom:80%;" /></p>
<h3 id="非凸规划">非凸规划：</h3>
<ul>
<li>可行解集不是凸集或目标函数不是凸函数</li>
</ul>
<h2 id="光滑非光滑规划">光滑/非光滑规划</h2>
<h3 id="光滑规划">光滑规划：</h3>
<ul>
<li>如果目标函数<span class="math inline">\(f_0(x)\)</span>是光滑的</li>
<li>光滑：在函数的每⼀点都可微</li>
</ul>
<h3 id="非光滑规划">非光滑规划</h3>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453017.png" alt="image-20230918211232374" style="zoom: 67%;" /></p>
<h2 id="连续离散规划">连续/离散规划</h2>
<h3 id="连续规划">连续规划：</h3>
<ul>
<li>可行解集是⼀个连续的域</li>
</ul>
<h3 id="离散规划">离散规划：</h3>
<ul>
<li>可行解集是离散的</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453034.png" alt="image-20230918211413357" style="zoom:80%;" /></p>
<h2 id="单目标多目标规划">单目标/多目标规划</h2>
<h3 id="多目标规划">多目标规划：</h3>
<ul>
<li>同时有多个需要优化的目标</li>
<li><span class="math inline">\(\min f_1(x),f_2(x)\)</span></li>
<li>可以通过加权转化为单目标优化问题</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453357.png" alt="image-20230918211623764" style="zoom:80%;" /></p>
<h2 id="博弈优化">博弈优化</h2>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453313.png" alt="image-20230918211659661" style="zoom:80%;" /></p>
<h2 id="确定随机优化">确定/随机优化</h2>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453128.png" alt="image-20230918211728804" style="zoom:80%;" /></p>
<h1 id="典型优化问题">典型优化问题</h1>
<h2 id="最小二乘">最小二乘</h2>
<h3 id="数据拟合问题">数据拟合问题：</h3>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453688.png" alt="image-20230918211820833" style="zoom:80%;" /></p>
<ul>
<li>目标函数</li>
</ul>
<p><span class="math display">\[
\min\sum^N_{i=1}\left(y_i-f(x_i)\right)^2
\]</span></p>
<h2 id="稀疏优化">稀疏优化</h2>
<h3 id="考虑线性方程组求解问题">考虑线性方程组求解问题</h3>
<p><span class="math display">\[
Ax=b
\]</span></p>
<blockquote>
<p>其中<span class="math inline">\(x\in R^n,b\in R^m,A\in R^{m\times
n}\)</span></p>
<p>向量<span class="math inline">\(b\)</span>的维度远小于向量<span
class="math inline">\(x\)</span>的维度，即<span
class="math inline">\(m\ll n\)</span></p>
</blockquote>
<ul>
<li>在信号传输过程中，希望通过接收到长度为<span
class="math inline">\(m\)</span>的数字信号<span
class="math inline">\(b\)</span>精确地重构原始信号<span
class="math inline">\(x\)</span></li>
<li>方程组是欠定的，因此存在无穷多个解，重构出原始信号看似很难</li>
</ul>
<h3
id="稀疏先验精确解u只有10的元素非零即u是如下l_0范数问题的最优解">稀疏先验：精确解<span
class="math inline">\(u\)</span>只有<span
class="math inline">\(10\%\)</span>的元素非零，即<span
class="math inline">\(u\)</span>是如下<span
class="math inline">\(l_0\)</span>范数问题的最优解:</h3>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191454632.png" alt="image-20230918212735058" style="zoom:80%;" /></p>
<ul>
<li><span class="math inline">\(l_0\)</span>范数优化问题是 NP
难问题</li>
<li>但<span
class="math inline">\(l_1\)</span>范数优化问题的解可以非常容易地通过现有优化算法得到</li>
<li>若<span class="math inline">\(A,b\)</span>满足一定的条件，向量<span
class="math inline">\(u\)</span>也是<span
class="math inline">\(l_1\)</span>范数优化问题的唯⼀最优解</li>
</ul>
<h2 id="低秩矩阵恢复">低秩矩阵恢复</h2>
<ul>
<li>某视频网站提供了约 48 万用户对 1 万 7
千多部电影的上亿条评级数据，希望对用户的电影评级进行预测，从而改进用户电影推荐系统，为每个用户更有针对性地推荐影片</li>
<li>用矩阵𝑀代表用户评分，每一行表示不同用户，每⼀列表示不同电影</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191454615.png" alt="image-20230918213023261" style="zoom: 80%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191454947.png" alt="image-20230918213048048" style="zoom:80%;" /></p>
<h2 id="深度学习">深度学习</h2>
<h3 id="深度学习分类问题">深度学习分类问题</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191454706.png"
alt="image-20230918213132779" />
<figcaption aria-hidden="true">image-20230918213132779</figcaption>
</figure>
<h1 id="求解优化问题">求解优化问题</h1>
<p>对有限资源进⾏有效分配和控制，并达到某种意义上的最优。</p>
<p>通常需要 • 对需求进行定性和定量分析 • 建立恰当的数学模型来描述该问题
• 探索研究模型和算法的理论性质，考察算法的计算性能等 •
设计合适的计算方法来寻找问题的最优解</p>
<h3 id="一般的最优化问题">一般的最优化问题</h3>
<ul>
<li>非常难以求解</li>
<li>可能需要非常长的计算时间，甚⾄找不到最优解</li>
</ul>
<h3 id="类相对简单的问题">⼀类相对简单的问题</h3>
<ul>
<li>最小二乘问题</li>
<li>线性规划问题</li>
<li>凸优化问题</li>
</ul>
<h3 id="更复杂的问题">更复杂的问题</h3>
<ul>
<li>离散、博弈、随机优化</li>
</ul>
<h3 id="定义域">定义域</h3>
<ul>
<li>凸集</li>
</ul>
<h3 id="目标函数">目标函数</h3>
<ul>
<li>凸函数</li>
</ul>
<h3
id="非凸优化问题与凸优化问题的转化">非凸优化问题与凸优化问题的转化</h3>
<ul>
<li>等价转化</li>
<li>对偶理论</li>
</ul>
<h2 id="优化算法">优化算法</h2>
<h3 id="闭式解closed-form-solution">闭式解（closed form solution）</h3>
<ul>
<li>如果我们能用代数表达式给出其最优解，那么这个解称为闭式解，对应的问题往往比较简单</li>
<li>例如：⼆次函数在有界区间上</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191454836.png" alt="image-20230918213626044" style="zoom: 67%;" /></p>
<h3
id="实际大多数问题是没有闭式解的需要通过迭代算法求解">实际大多数问题是没有闭式解的，需要通过迭代算法求解</h3>
<ul>
<li>迭代算法的基本思想是:从⼀个初始点<span
class="math inline">\(x_0\)</span>出发，按照某种给定的规则进行迭代，得到⼀个序列<span
class="math inline">\(\{x^k\}\)</span>如果迭代在有限步内终止，那么希望最后一个点就是优化问题的解</li>
<li>例如：梯度类算法、线搜索法、罚函数法</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191454918.png" alt="image-20230918213839201" style="zoom:80%;" /></p>
<h2 id="常用优化技巧">常用优化技巧</h2>
<h3 id="泰勒展开">泰勒展开</h3>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191454151.png" alt="image-20230918213955711" style="zoom:80%;" /></p>
<h3 id="对偶">对偶</h3>
<ul>
<li>每个优化问题都有对应的对偶问题，特别是凸的情形，当原始问题比较难解的时候，其对偶问题可能很容易求解</li>
</ul>
<h3 id="拆分">拆分</h3>
<ul>
<li>通过引入变量等方法，讲⼀个复杂的优化问题拆分成多个相对简单的问题</li>
</ul>
]]></content>
      <categories>
        <category>最优化方法</category>
      </categories>
      <tags>
        <tag>学科</tag>
        <tag>最优化方法</tag>
      </tags>
  </entry>
  <entry>
    <title>凸优化问题</title>
    <url>/2023/09/21/2023/%E6%9C%80%E4%BC%98%E5%8C%96/%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>凸优化问题</p>
</blockquote>
<span id="more"></span>
<h1 id="优化问题的标准形式">优化问题的标准形式</h1>
<h2 id="一般优化问题">一般优化问题</h2>
<h3 id="优化问题">优化问题</h3>
<p><span class="math display">\[
\min f_0(x).\\
\text{s.t.}\ \ f_i(x)\le0,\quad i=1,...,m\\
h_i(x)=0,\quad i=1,...,
\]</span></p>
<blockquote>
<p>其中</p>
<ul>
<li><span
class="math inline">\(x=(x_1,x_2,...,x_n)\)</span>：优化变量(variable)</li>
<li><span class="math inline">\(f_0:
\mathbb{R}^n\rightarrow\mathbb{R}\)</span>：目标函数(Objective
function)</li>
<li><span class="math inline">\(f_i:
\mathbb{R}^n\rightarrow\mathbb{R},i=1,...m\)</span>：不等式约束(Constraints)</li>
<li><span class="math inline">\(h_i:
\mathbb{R}^n\rightarrow\mathbb{R},i=1,...p\)</span>：等式约束(Constraints)</li>
<li><span class="math inline">\(m=p=0：\)</span>无约束问题</li>
</ul>
</blockquote>
<h2 id="优化问题的最优解">优化问题的最优解</h2>
<ul>
<li><p>优化问题的域(domain) <span class="math display">\[
D=\bigcap_{i=0}^m domf_i\cap\bigcap_{i=1}^p domh_i
\]</span></p></li>
<li><p>可行解集（feasible set） <span class="math display">\[
𝑋 = \{𝑥 ∈ 𝐷且所有约束条件可以满⾜\}
\]</span></p></li>
<li><p>问题的最优值（optimal value） <span class="math display">\[
p^* = \inf\{f_0(𝑥)|𝑥 ∈ 𝑋_f\}
\]</span></p></li>
<li><p>最优解（optimal point/solution） <span class="math display">\[
若x^*可⾏，且f_0(x^*)=p^*
\]</span></p></li>
<li><p>最优解集（optimal set） <span class="math display">\[
x_{opt}=\{x|x\in X_f,f_0(x^*)=p^*\}
\]</span></p></li>
<li><p><span class="math inline">\(\varepsilon\)</span>-次优解集（ <span
class="math inline">\(\varepsilon\)</span>–suboptimal set） <span
class="math display">\[
X_\varepsilon=\{x|x\in X_f,f_0(x^*)\le p^*+\varepsilon\}
\]</span></p></li>
</ul>
<h2 id="局部最优解locally-optimal">局部最优解（Locally optimal）</h2>
<ul>
<li>𝑥为局部最优解，如果<span class="math inline">\(\exist
R&gt;0\)</span>使得<span
class="math inline">\(x\)</span>为以下问题的最优解：</li>
<li>所有局部最优解构成的解集为<span
class="math inline">\(X_loc\)</span></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309211803862.png" alt="image-20230921180256354" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309211803986.png" alt="image-20230921180309308" style="zoom:67%;" /></p>
<h2 id="不同解集的关系">不同解集的关系</h2>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309211806319.png" alt="image-20230921180644673" style="zoom:80%;" /></p>
<h1 id="凸优化问题">凸优化问题</h1>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309211807398.png"
alt="image-20230921180734622" />
<figcaption aria-hidden="true">image-20230921180734622</figcaption>
</figure>
<p>例：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309271332232.png"
alt="image-20230921181430569" />
<figcaption aria-hidden="true">image-20230921181430569</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309271332037.png"
alt="image-20230921181450725" />
<figcaption aria-hidden="true">image-20230921181450725</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309271332730.png"
alt="image-20230921181528931" />
<figcaption aria-hidden="true">image-20230921181528931</figcaption>
</figure>
<h2 id="重要性质局部最优全部最优">重要性质：局部最优=全部最优</h2>
<h3 id="局部最优全部最优">局部最优=全部最优</h3>
<ul>
<li><p>局部最优：存在<span
class="math inline">\(R&gt;0\)</span>使得<span
class="math inline">\(x\)</span>为以下问题的最优解： <span
class="math display">\[
\min(overz)\quad f_0(z)\\
\text{s.t.}\quad\quad f_i(z)\le0,\quad i  =1,...,m\\
\quad \quad \quad h_i(z)=1,\quad i  =1,...,p\\
\|z-x\|_2\le R
\]</span></p></li>
<li><p>全局最优：<span class="math inline">\(p^*=\inf \{f_0(x)|x\in
D_f\},\quad f_0(x^*)=p^*\)</span></p></li>
</ul>
<h2 id="最优条件">最优条件</h2>
<h3 id="可微目标函数下的最优条件">可微目标函数下的最优条件</h3>
<h4 id="凸函数的一阶条件">凸函数的一阶条件</h4>
<ul>
<li><span class="math inline">\(f_0\)</span>可微，则<span
class="math inline">\(f_0\)</span>为凸函数<span
class="math inline">\(\Rightarrow domf\)</span>为凸集</li>
<li><span class="math inline">\(f_0(y)\ge f_0(x)+\nabla f_0^T (x)(y-x),
\forall x,y\in dom f\)</span></li>
</ul>
<h4 id="最优条件-1">最优条件</h4>
<ul>
<li><span class="math inline">\(x\in X\)</span>最优<span
class="math inline">\(\Leftrightarrow \nabla f_0(x)^T (y-x)\ge0 \text{
for all }y\in X\)</span></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309221758437.png" alt="image-20230921182738352" style="zoom:67%;" /></p>
<h2 id="最优条件特殊情况">最优条件（特殊情况）</h2>
<h3 id="无约束问题">无约束问题：</h3>
<p><span class="math inline">\(x\)</span>为最优解的充分必要条件 <span
class="math display">\[
x\in \text{dom}f_0,\quad \nabla f_0(x)=0
\]</span></p>
<h3 id="等式约束问题">等式约束问题：</h3>
<p><span class="math display">\[
\min\quad f_0(x)\quad \text{s.t.}\quad Ax=b
\]</span></p>
<p><span
class="math inline">\(x\)</span>为最优解的充分必要条件。存在<span
class="math inline">\(v\)</span>使得 <span class="math display">\[
x\in \text{dom}f_0,\quad Ax=b,\quad \nabla f_0(x)+A^Tv=0
\]</span></p>
<h1 id="典型优化问题">典型优化问题</h1>
<h2 id="线性规划linear-programming">线性规划（Linear Programming）</h2>
<p><span class="math display">\[ {align*}
\min\quad c^Tx+d\\
\text{s.t.}\quad Gx\le h\\
Ax=b
\]</span> {align*}</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309221758062.png"
alt="image-20230921183845593" />
<figcaption aria-hidden="true">image-20230921183845593</figcaption>
</figure>
<h2 id="二次规划quadratic-programming">二次规划（Quadratic
Programming）</h2>
<p><span class="math display">\[
\min\quad (1/2)x^TPx+q^Tx+r\\
\text{s.t.}\quad Gx\le h\\
Ax=b
\]</span></p>
<ul>
<li><span class="math inline">\(P\in S^n_+\)</span>，凸优化问题</li>
<li>可行解时多面体，虚线为等高线</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309221758169.png" alt="image-20230921184237723" style="zoom:67%;" /></p>
<h2 id="二次约束二次规划qcqp">二次约束二次规划（QCQP）</h2>
<p><span class="math display">\[
\min\quad (1/2)x^TP_0x+q_0^Tx+r_0\\
\text{s.t.}\quad (1/2)x^TP_ix+q_i^Tx+r_i\le0,\quad i=1,...,m\\
Ax=b
\]</span></p>
<ul>
<li><span class="math inline">\(P\in
S^n_+\)</span>，目标函数与不等式约束都是二次凸函数</li>
<li>可行解集为m个椭球和⼀个仿射集的交集</li>
</ul>
<h3 id="例-最小二乘问题least-squares-problem">例-最小二乘问题（Least
Squares Problem）</h3>
<p><span class="math display">\[
\min\|Xw-y\|^2_2\\
\min\quad w^TX^TXw-2y^TXw+y^Ty
\]</span></p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309221758196.png" alt="image-20230921202149224" style="zoom:50%;" /></p>
<ul>
<li>无约束QP问题</li>
<li>解析解：<span class="math inline">\((X^TX)^{-1}X^Ty\)</span></li>
<li>假设有约束<span class="math inline">\(u_i\le w_i\le
l_i\)</span>，则是一个具有等式约束的QP问题</li>
</ul>
<h3 id="例-投资组合问题portfolio-problem">例-投资组合问题（portfolio
problem）</h3>
<p><span class="math display">\[
\begin{aligned}
&amp; \max \sum_{i=1}^n x_i p_i . \\
&amp; \text { s.t. } \sum_{i=1}^n x_i \leq B, x_i \geq 0
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(x_i\)</span>为第<span
class="math inline">\(i\)</span>种产品的投资额，<span
class="math inline">\(B\)</span>为总资金， <span
class="math inline">\(p_i\)</span>为收益率</p>
<ul>
<li>在实际情况中， <span
class="math inline">\(p_i\)</span>⼀般为概率分布
<ul>
<li><span class="math inline">\(\bar{p}=[1.05, 1.05, 1]\)</span></li>
<li><span class="math inline">\(\sum =[1.2, 2, 0]\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{array}{ll}
\min &amp; \sum_{i=1}^n X^T \sum X \\
\text { s.t. } &amp; \bar{p}^T X \geq r_{\text {min }}, I^T X=B, X \geq
0
\end{array}
\]</span></p>
<h2 id="复合优化问题">复合优化问题</h2>
<p><span class="math display">\[
\min \psi (x)=f(x)+h(x)
\]</span></p>
<p>其中，<span
class="math inline">\(f(x)\)</span>一般是凸的、光滑的，<span
class="math inline">\(h(x)\)</span>一般是凸的，但不一定光滑</p>
<p>应用场景：</p>
<ul>
<li>岭回归：<span class="math inline">\(f(x)\)</span>为最小二乘，<span
class="math inline">\(h(x)=\|x\|_2\)</span></li>
<li>Lasso：<span class="math inline">\(f(x)\)</span>为最小二乘，<span
class="math inline">\(h(x)=\|x\| _1\)</span></li>
<li>l1范数正则化逻辑回归：<span class="math inline">\(f(x)=\sum_{i=1}^m
\ln(1+\exp(-b_i\cdot a^T_i x)),h(x)=\|x\|_1\)</span></li>
<li>l1范数正则化支持向量机：<span
class="math inline">\(Cf(x)=\sum_{i=1}^m \max\{1+(-b_i(a^T_i x
+y),0\},h(x)=\|x\|_1\)</span></li>
</ul>
<h3 id="l1正则化与l2正则化">l1正则化与l2正则化</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309271318100.png"
alt="image-20230927131817702" />
<figcaption aria-hidden="true">image-20230927131817702</figcaption>
</figure>
<h2 id="矩阵优化">矩阵优化</h2>
<p><span class="math display">\[
\min \quad\psi (x)
\]</span></p>
<ul>
<li><span class="math inline">\(X包含n\times n个元素\)</span></li>
<li>半定规划</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\min &amp; c^{\mathrm{T}} x \\
\text { s.t. } &amp; x_1 A_1+x_2 A_2+\cdots+x_n A_n+B \preceq 0 \\
&amp; G x=h,
\end{aligned}
\]</span></p>
<h3 id="例-低秩矩阵恢复">例-低秩矩阵恢复</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309271329954.png"
alt="image-20230927132945693" />
<figcaption aria-hidden="true">image-20230927132945693</figcaption>
</figure>
<h2 id="整数规划非凸">整数规划（非凸）</h2>
<p><span class="math display">\[
\begin{array}{ll}
\min &amp; c^{\top} x \\
\text { s.t. } &amp; A x \leqslant b, \\
&amp; x_i \geqslant 0, i=1,2, \cdots, n, \\
&amp; x_i \in \mathbb{Z}, i=1,2, \cdots, n,
\end{array}
\]</span></p>
<blockquote>
<p>其中Z为所有的整数集合</p>
</blockquote>
<h3 id="例-仓库位置选取问题">例-仓库位置选取问题</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309271332262.png"
alt="image-20230927133202477" />
<figcaption aria-hidden="true">image-20230927133202477</figcaption>
</figure>
]]></content>
      <categories>
        <category>最优化方法</category>
      </categories>
      <tags>
        <tag>学科</tag>
        <tag>最优化方法</tag>
      </tags>
  </entry>
  <entry>
    <title>凸函数（Convex Function）</title>
    <url>/2023/09/21/2023/%E6%9C%80%E4%BC%98%E5%8C%96/%E5%87%B8%E5%87%BD%E6%95%B0%EF%BC%88Convex-Function%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>第三课：凸函数</p>
</blockquote>
<span id="more"></span>
<h1 id="凸函数的定义">凸函数的定义</h1>
<h2 id="定义1">定义1</h2>
<p>对于一个函数<span
class="math inline">\(f:\mathbb{R}^n\rightarrow\mathbb{R}\)</span>，如果<span
class="math inline">\(domf\)</span>为凸集，且： <span
class="math display">\[
f(\theta x+(1-\theta)y)\le\theta f(x)+(1-\theta)f(y)
\]</span> 对所有的<span class="math inline">\(x,y\in domf,0\le\theta\le
1\)</span>成立，则<span
class="math inline">\(f\)</span>为（下）凸函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309211258794.png" alt="image-20230921125358565" style="zoom:67%;" /></p>
<blockquote>
<p>连接凸函数的图像上任意两点的线段都在函数图像上方</p>
</blockquote>
<ul>
<li><p><span class="math inline">\(f\)</span>是凸函数，则<span
class="math inline">\(-f\)</span>是凹函数</p></li>
<li><p>如果<span class="math inline">\(dom f\)</span>是凸集，且 <span
class="math display">\[
f(\theta x+(1-\theta)y)&lt;\theta f(x)+(1-\theta)f(y)
\]</span></p></li>
</ul>
<blockquote>
<p>对所有的<span class="math inline">\(x,y\in domf,x\neq y,0&lt;\theta
&lt;1\)</span>成立，则<span
class="math inline">\(f\)</span>是严格凸函数</p>
</blockquote>
<h2 id="定义2">定义2</h2>
<ul>
<li><p><span
class="math inline">\(f\)</span>是凸函数的充分必要条件为：<span
class="math inline">\(\forall x,v\in
domf,g(t)=f(x+tv)\)</span>是凸函数</p></li>
<li><p>证明</p></li>
</ul>
<h2 id="定义3一阶条件">定义3（一阶条件）</h2>
<ul>
<li><p>可微：如果<span class="math inline">\(dom
f\)</span>为开集，且函数的导数： <span class="math display">\[
\nabla f(x)=(\frac{\partial f(x)}{\partial x_1},\frac{\partial
f(x)}{\partial x_2},···,\frac{\partial f(x)}{\partial x_n})
\]</span> 对所有定义域中的值都存在，则函数<span
class="math inline">\(f\)</span>可微</p></li>
<li><p>一阶条件：对于可微函数<span
class="math inline">\(f\)</span>，如果<span
class="math inline">\(domf\)</span>为凸集，则<span
class="math inline">\(f\)</span>为凸函数当且仅当： <span
class="math display">\[
f(y)\ge f(x)+\nabla f(x)^T (y-x)\quad \text{for all }x,y\in domf
\]</span></p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309211258727.png" alt="image-20230921125426877" style="zoom:67%;" /></p>
<blockquote>
<p>意义：凸函数在局部的一阶泰勒展开是对函数值的低估</p>
</blockquote>
<h3 id="一阶条件的证明">一阶条件的证明</h3>
<ul>
<li><p>=&gt;</p>
<p>f</p></li>
<li><p>&lt;=</p></li>
</ul>
<h2 id="定义4二阶条件">定义4（二阶条件）</h2>
<ul>
<li><p>二阶可微：如果<span
class="math inline">\(domf\)</span>为开集，且函数的<span
class="math inline">\(Hessian\)</span>矩阵满足<span
class="math inline">\(\nabla^2 f(x)\in S^n\)</span> <span
class="math display">\[
\nabla^2 f(x)_{ij}=\frac{\partial^2 f(x)}{\partial x_i \partial
x_j},i,j=1,...,.
\]</span> 对所有定义域中的值都存在，则函数<span
class="math inline">\(f\)</span>二阶可微</p></li>
<li><p>二阶条件：对于二阶可微函数<span
class="math inline">\(f\)</span>，如果定义域为凸集</p>
<ul>
<li><p><span class="math inline">\(f\)</span>为凸函数当且仅当： <span
class="math display">\[
\nabla^2 f(x)\succeq 0\quad \text{for all }x\in domf
\]</span></p></li>
<li><p>如果对所有定义域内的<span
class="math inline">\(x\)</span>满足<span class="math inline">\(\nabla^2
f(x)\succ 0\)</span>，则<span
class="math inline">\(f\)</span>为严格凸函数</p></li>
</ul></li>
</ul>
<h1 id="常见的凸函数">常见的凸函数</h1>
<h2 id="一维空间举例">一维空间举例</h2>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309211258649.png" alt="image-20230921125640656" style="zoom: 67%;" /></p>
<h2 id="向量范数">向量范数</h2>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309211258592.png" alt="image-20230921125652921" style="zoom: 67%;" /></p>
<h2 id="多维空间举例">多维空间举例</h2>
<h3 id="多维向量rn">多维向量<span
class="math inline">\(R^n\)</span></h3>
<ul>
<li>仿射函数：<span class="math inline">\(f(x)=a^Tx+b\)</span></li>
<li>范数函数：<span
class="math inline">\(\|x\|_p=(\sum_{i=1}^{n}|x_i|^p)^{\frac{1}{p}}\quad\text{for
}p\ge1\)</span></li>
<li>极大值函数：<span
class="math inline">\(f(x)=\max\{x_1,...,x_n\},x\in R^m\)</span></li>
<li><span class="math inline">\(L0\)</span>范数：<span
class="math inline">\(x\)</span>中非零元素的个数</li>
</ul>
<h3 id="例二次函数">例：二次函数</h3>
<ul>
<li><p>二次函数：<span
class="math inline">\(f(x)=\frac{1}{2}x^TPx+q^Tx+r,P\in S^n\)</span>
<span class="math display">\[
\nabla f(x)=Px+q,\quad\nabla^2f(x)=P
\]</span> 当P为半正定矩阵<span class="math inline">\((P\succeq
0)\)</span>时为凸函数</p></li>
<li><p>最小二乘目标函数：<span
class="math inline">\(f(x)=\|Ax-b\|^2_2\)</span> <span
class="math display">\[
\nabla f(x)=2A^T(Ax-b),\quad\nabla^2 f(x)=2A^TA
\]</span> 对任意的<span
class="math inline">\(A\)</span>都为凸函数</p></li>
<li><p>二次函数比线性函数：<span
class="math inline">\(f(x,y)=x^2/y\)</span>对所有的<span
class="math inline">\(y&gt;0\)</span>都为凸函数</p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309211258784.png" alt="image-20230921125739507" style="zoom:67%;" /></p>
<h2 id="半正定矩阵的性质">半正定矩阵的性质</h2>
<p>矩阵<strong>A</strong>为行列式，则存在以下性质：</p>
<ul>
<li><strong>A</strong>的特征值均为负的。</li>
<li>存在n阶实矩阵<strong>C</strong>，使<span
class="math inline">\(A=C^TC.\)</span></li>
<li><strong>A</strong>的行列式是负的</li>
</ul>
<h1 id="保持凸性的操作">保持凸性的操作</h1>
<h2
id="验证个函数是否是凸函数的方法">验证⼀个函数是否是凸函数的方法</h2>
<ol type="1">
<li>根据3种定义</li>
<li>验证函数是由多个相对简单的凸函数通过一些保持凸性的操作来得到</li>
</ol>
<h2 id="保持凸性的操作1非负加权和">保持凸性的操作1：非负加权和</h2>
<ul>
<li>命题：若<span
class="math inline">\(f_1,...,f_m\)</span>为凸函数，则<span
class="math inline">\(f=\sum^m_{i=1}w_if_i\)</span>为凸函数，<span
class="math inline">\(w_i\ge0\)</span></li>
<li>证明
<ol type="1">
<li>定义域是否为凸集</li>
</ol></li>
</ul>
<h2 id="保持凸性的操作2仿射组合">保持凸性的操作2：仿射组合</h2>
<ul>
<li>命题：若<span class="math inline">\(f\)</span>为凸函数，则<span
class="math inline">\(𝑓(𝐴𝑥+𝑏)\)</span>为凸函数</li>
<li>证明</li>
</ul>
<h2 id="保持凸性的操作3最大化极大化">保持凸性的操作3：最大化/极大化</h2>
<h3 id="最大化与极大化">最大化与极大化</h3>
<ul>
<li><p><span class="math inline">\(\max\)</span>：最大值</p></li>
<li><p><span class="math inline">\(\sup\)</span>：上确界</p></li>
<li><p>命题：若<span
class="math inline">\(f_1,...,f_m\)</span>为凸函数，则<span
class="math inline">\(f(x)=\max\{f_1(x),...,f_m(x)\}\)</span>为凸函数</p>
<ul>
<li>证明：</li>
</ul></li>
<li><p>命题：若<span class="math inline">\(f(x,y)\)</span>对所有<span
class="math inline">\(y\in A\)</span>为关于<span
class="math inline">\(x\)</span>的凸函数，则<span
class="math inline">\(f(x)=\sup_{y\in A}f(x,y)\)</span>为凸函数</p></li>
</ul>
<h2
id="保持凸性的操作4标量函数的组合">保持凸性的操作4：标量函数的组合</h2>
<p>对于函数<span class="math inline">\(g:R^n\to R^k\)</span>与函数<span
class="math inline">\(h:R^k\to R\)</span>，函数组合为<span
class="math inline">\(f(x)=h(g(x))\)</span></p>
<p>考虑<span class="math inline">\(n=k=1\)</span>的情况</p>
<p><span class="math inline">\(f\)</span>为凸函数如果：<span
class="math inline">\(\begin{cases}g是凸函数，h是凹函数，h递增\\g是凹函数，h是凸函数，h递减\end{cases}\)</span>
<span class="math display">\[
f&#39;&#39;(x)=h&#39;&#39;(g(x)g&#39;(x))^2+h&#39;(g(x))g&#39;&#39;(x).
\]</span></p>
<blockquote>
<p>例：</p>
<p><span class="math inline">\(\exp
g(x)当g是凸函数时为凸函数\)</span></p>
<p><span
class="math inline">\(1/g(x)当g是凹函数且为正时为凸函数\)</span></p>
</blockquote>
<h1 id="共轭函数conjugate-function">共轭函数（conjugate function）</h1>
<h2 id="函数f的共轭定义">函数<span
class="math inline">\(f\)</span>的共轭定义</h2>
<p><span class="math display">\[
f^*(y)=\sup_{x\in domf}(y^Tx-f(x))
\]</span></p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309211700984.png" alt="image-20230921170043534" style="zoom:80%;" /></p>
<blockquote>
<p>性质：<span class="math inline">\(f^*(y)\)</span>一定为凸函数</p>
</blockquote>
]]></content>
      <categories>
        <category>最优化方法</category>
      </categories>
      <tags>
        <tag>学科</tag>
        <tag>最优化方法</tag>
      </tags>
  </entry>
  <entry>
    <title>凸集（Convex Set）</title>
    <url>/2023/09/19/2023/%E6%9C%80%E4%BC%98%E5%8C%96/%E5%87%B8%E9%9B%86%EF%BC%88Convex-Set%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>第二课：凸集(Convex Set)</p>
</blockquote>
<span id="more"></span>
<h1 id="重要定义">重要定义</h1>
<h2 id="仿射集">仿射集</h2>
<h3 id="直线">直线：</h3>
<p>对于穿过<span
class="math inline">\(x_1,x_2\)</span>两个不同的点的直线，所有满足以下条件的点：
<span class="math display">\[
x=\theta x_1+(1-\theta)x_2,\theta\in\mathbb{R}
\]</span>
<img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191452821.png" alt="image-20230919141052729" style="zoom:67%;" /></p>
<h3 id="仿射集-1">仿射集</h3>
<p>一个集合<span class="math inline">\(C\)</span>是仿射集，若<span
class="math inline">\(\forall x_1,x_2\in C\)</span>，连接<span
class="math inline">\(x_1,x_2\)</span>的直线也在<span
class="math inline">\(C\)</span>内</p>
<blockquote>
<p>思考：</p>
<ul>
<li>该条直线上所有的点组成的集合（是）</li>
<li>空集、点、线段是仿射集吗？（空集是，点是，线段不是）</li>
<li>实数集、正实数集、整数集是仿射集吗？（实数集是、正实数集不是、整数集不是）</li>
</ul>
</blockquote>
<h2 id="凸集convex-set">凸集（Convex Set）</h2>
<h3 id="线段">线段：</h3>
<p>对于穿过<span
class="math inline">\(x_1,x_2\)</span>两点的直线，所有满足以下条件的点:
<span class="math display">\[
x=\theta x_1+(1-\theta)x_2,0\le\theta\le1
\]</span></p>
<h3 id="凸集">凸集：</h3>
<p>集合中任意两点组成的线段仍在该集合中： <span class="math display">\[
x_1,x_2\in C,0\le\theta\le1.\Rightarrow\theta x_1+(1-\theta)x_2\in C
\]</span> 例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191452541.png" alt="image-20230919141112752"  /></p>
<blockquote>
<p>思考：</p>
<ul>
<li>点、直线（点是，直线也是）</li>
<li>实数集、正实数集、整数集是否为凸集（都不是）</li>
<li>仿射集是否为凸集（是）</li>
</ul>
</blockquote>
<h2 id="凸组合与凸包">凸组合与凸包</h2>
<h3 id="凸组合convex-combination">凸组合（Convex Combination）：</h3>
<p>对于任意点k个点：<span
class="math inline">\(x_1,x_2,...,x_k\)</span>，凸组合是以下的形式：
<span class="math display">\[
x=\theta_1 x_1+\theta_2 x_2+···\theta_k x_k
\]</span></p>
<blockquote>
<p>其中<span
class="math inline">\(\theta_1+\theta_2+···+\theta_k=1,\theta_i\ge0\)</span></p>
</blockquote>
<p><span class="math inline">\(C\)</span>为凸集<span
class="math inline">\(\Leftrightarrow\)</span><span
class="math inline">\(C\)</span>中任意元素点凸组合属于<span
class="math inline">\(C\)</span></p>
<h3 id="凸包convex-hull">凸包（Convex Hull）：</h3>
<p><span class="math inline">\(conv C\)</span>：所有集合<span
class="math inline">\(C\)</span>中的点的凸组合，是包含<span
class="math inline">\(S\)</span>的最小的凸集</p>
<p>用一个绳子连起来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191452529.png" alt="image-20230919141134184" style="zoom:80%;" /></p>
<h2 id="凸锥convex-cone">凸锥（Convex Cone）</h2>
<h3 id="锥">锥：</h3>
<p><span class="math inline">\(C\)</span>为锥<span
class="math inline">\(\Leftrightarrow\)</span>对于<span
class="math inline">\(C\)</span>中任意的点<span
class="math inline">\(x\)</span>，<span class="math inline">\(\theta
x\in C,\theta\ge0\)</span></p>
<h3 id="凸锥">凸锥：</h3>
<p>对于任意的两个点：<span
class="math inline">\(x_1,x_2\)</span>，凸锥是以下的形式： <span
class="math display">\[
x=\theta_1 x_1+\theta_2 x_2
\]</span></p>
<blockquote>
<p>其中<span
class="math inline">\(\theta_1\ge0,\theta_2\ge0\)</span></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/image-20230919141149722.png" alt="image-20230919141149722" style="zoom:67%;" /></p>
<blockquote>
<p>思考：</p>
<ul>
<li>原点是否一定在凸锥上？（是）</li>
<li>经过原点的射线（是）</li>
<li>经过原点的直线（是）</li>
<li>凸锥是凸集吗？（是）</li>
</ul>
</blockquote>
<h2 id="仿射集凸集凸锥的关系">仿射集、凸集、凸锥的关系</h2>
<h3 id="定义">定义：</h3>
<ul>
<li>仿射集：<span
class="math inline">\(\theta_1+\theta_2=1\)</span></li>
<li>凸集：<span
class="math inline">\(\theta_1+\theta_2=1,\theta_i\ge0\)</span></li>
<li>凸锥：<span class="math inline">\(\theta_i\ge0\)</span></li>
</ul>
<h3 id="关系">关系：</h3>
<ul>
<li>仿射集<span class="math inline">\(\subseteq\)</span>凸集</li>
<li>凸锥<span class="math inline">\(\subseteq\)</span>凸集</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191452743.png" alt="image-20230919141203364" style="zoom:67%;" /></p>
<h1 id="几种重要的凸集">几种重要的凸集</h1>
<h2 id="超平面和半空间">超平面和半空间</h2>
<h3 id="超平面">超平面：</h3>
<p>满足以下条件的点的集合： <span class="math display">\[
\{x|a^T \boldsymbol{x}=b\}(a\neq0)
\]</span>
<img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191452636.png" alt="image-20230919141218903" style="zoom:67%;" /></p>
<blockquote>
<p>超平面是仿射的，也是凸的</p>
</blockquote>
<h3 id="半空间">半空间：</h3>
<p><span class="math display">\[
\{x|a^T\boldsymbol{x}\le b(a\neq0)\}
\]</span></p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191452865.png" alt="image-20230919141230877" style="zoom:67%;" /></p>
<h2 id="多面体">多面体</h2>
<ul>
<li><span class="math inline">\(\{x|Ax\le b,Cx=d\}\)</span></li>
<li><span class="math inline">\(A\in R^{m\times n},C\in R^{p\times
n}\)</span></li>
<li>多面体是有限个半空间和超平面的交集</li>
<li>多面体是凸集</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191452106.png" alt="image-20230919141245402" style="zoom:67%;" /></p>
<h2 id="对称半正定矩阵">对称半正定矩阵</h2>
<h3 id="预备知识">预备知识：</h3>
<h4 id="对称矩阵sn">对称矩阵<span
class="math inline">\(S^n\)</span>：</h4>
<p>是指以主对角线为对称轴，各元素对应相等的矩阵 <span
class="math display">\[
\begin{bmatrix}
a_{11}&amp;a_{12}&amp;a_{13}&amp;···&amp;a_{1n}\\
a_{21}&amp;a_{22}&amp;a_{23}&amp;···&amp;a_{2n}\\
a_{31}&amp;a_{32}&amp;a_{33}&amp;···&amp;a_{3n}\\
\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\
a_{m1}&amp;a_{m2}&amp;a_{m3}&amp;···&amp;a_{mn}
\end{bmatrix}
\]</span></p>
<h3 id="对称半正定矩阵-1">对称半正定矩阵：</h3>
<p>给定一个大小为<span class="math inline">\(n\times
n\)</span>的<strong>实对称矩阵</strong><span
class="math inline">\(A\)</span>，若对于任意长度的<span
class="math inline">\(n\)</span>的非零向量<span
class="math inline">\(x\)</span>，有<span
class="math inline">\(x^TAx\ge0\)</span>恒成立，则矩阵<span
class="math inline">\(A\)</span>是一个半 正定矩阵</p>
<blockquote>
<p>堆成正定矩阵<span class="math inline">\(S^n_{++}\)</span></p>
</blockquote>
<h3 id="对称半正定矩阵集合">对称半正定矩阵集合：</h3>
<p><span class="math display">\[
S^n_+=\{X\in S^n|X\succeq0\}
\]</span></p>
<blockquote>
<p>对称半正定矩阵集合是凸锥</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191452865.png" alt="image-20230919141303814" style="zoom:67%;" /></p>
<h2 id="球与椭球">球与椭球</h2>
<h3 id="球">球：</h3>
<p>满足以下条件的点的集合： <span class="math display">\[
B(x_c,r)=\{x|\|x-x_c\|_2\le r\}=\{x_c+ru|\|u\|_2\le1\}
\]</span></p>
<h3 id="椭球">椭球：</h3>
<p><span class="math display">\[
\{x|(x-x_c)^TP^{-1}(x-x_c)\le1\},P\in S^n_{++}
\]</span></p>
<blockquote>
<p>球是凸集</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453505.png" alt="image-20230919141315764" style="zoom:67%;" /></p>
<h1 id="保凸的运算">保凸的运算</h1>
<h2 id="交集">交集</h2>
<p>定理：任意多个凸集的交集为凸集</p>
<h2 id="仿射变换">仿射变换</h2>
<p>定理：设<span
class="math inline">\(f:\mathbb{R}^n\rightarrow\mathbb{R}^m\)</span>是仿射变换<span
class="math inline">\((f(x)=Ax+b, A\in\mathbb{R}^{m\times n},b\in
\mathbb{R}^m)\)</span>则：</p>
<p>（1）凸集在<span class="math inline">\(f\)</span>下的像是凸集： <span
class="math display">\[
S\subseteq\mathbb{R}^n是凸集\Rightarrow
f(S)\overset{\text{def}}{=}\{f(x)|x\in S\}是凸集；
\]</span> （2）凸集在<span
class="math inline">\(f\)</span>下的原像是凸集： <span
class="math display">\[
C\subseteq\mathbb{R}^m\Rightarrow
f^{-1}(C)\overset{\text{def}}{=}\{x\in\mathbb{R}^n|f(x)\in C\}是凸集.
\]</span></p>
<blockquote>
<p>缩放、平移和投影都是仿射变换</p>
</blockquote>
<h1 id="分离超平面定理">分离超平面定理</h1>
<p>如果<span class="math inline">\(C\)</span>和<span
class="math inline">\(D\)</span>是不相交的两个凸集，则存在非零向量<span
class="math inline">\(a\)</span>和常数<span
class="math inline">\(b\)</span>，使得 <span class="math display">\[
a^Tx\le b, \forall x\in C,且a^Tx\ge b,\forall x\in D,
\]</span>
<img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453319.png" alt="image-20230919141339133" style="zoom:80%;" /></p>
<h1 id="支撑超平面定理">支撑超平面定理</h1>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202309191453641.png"
alt="image-20230919141413149" />
<figcaption aria-hidden="true">image-20230919141413149</figcaption>
</figure>
]]></content>
      <categories>
        <category>最优化方法</category>
      </categories>
      <tags>
        <tag>学科</tag>
        <tag>最优化方法</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载过程</title>
    <url>/2024/03/28/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>关于类加载过程的一些问题</p>
</blockquote>
<span id="more"></span>
<h1 id="类的声明周期">类的声明周期</h1>
<p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为
7
个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</p>
<p>这 7 个阶段的顺序如下图所示：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403281147618.png"
alt="一个类的完整生命周期 图源：JavaGuide" />
<figcaption aria-hidden="true">一个类的完整生命周期
图源：JavaGuide</figcaption>
</figure>
<h1 id="类加载过程">类加载过程</h1>
<p><strong>Class
文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class
文件呢？</strong></p>
<p>系统加载 Class
类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403281148566.png"
alt="类加载过程 图源：JavaGuide" />
<figcaption aria-hidden="true">类加载过程 图源：JavaGuide</figcaption>
</figure>
<h2 id="加载">加载</h2>
<p>类加载过程的第一步，主要完成下面 3 件事情：</p>
<ol type="1">
<li>通过全类名获取定义此类的二进制字节流。</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的 <code>Class</code>
对象，作为方法区这些数据的访问入口。</li>
</ol>
<p>虚拟机规范上面这 3
点并不具体，因此是非常灵活的。比如："通过全类名获取定义此类的二进制字节流"
并没有指明具体从哪里获取（ <code>ZIP</code>、
<code>JAR</code>、<code>EAR</code>、<code>WAR</code>、网络、动态代理技术运行时动态生成、其他文件生成比如
<code>JSP</code>...）、怎样获取。</p>
<p>加载这一步主要是通过我们后面要讲到的 <strong>类加载器</strong>
完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由
<strong>双亲委派模型</strong>
决定（不过，我们也能打破由双亲委派模型）。</p>
<blockquote>
<p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容在<a
href="https://javaguide.cn/java/jvm/classloader.html">类加载器详解open
in new
window</a>这篇文章中有详细介绍到。阅读本篇文章的时候，大家知道有这么个东西就可以了。</p>
</blockquote>
<p>每个 Java 类都有一个引用指向加载它的
<code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code>
创建的，而是 JVM
在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取
<code>ClassLoader</code> 的时候和该数组的元素类型的
<code>ClassLoader</code> 是一致的。</p>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的
<code>loadClass()</code> 方法）。</p>
<p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p>
<h2 id="验证">验证</h2>
<p><strong>验证是连接阶段的第一步，这一阶段的目的是确保 Class
文件的字节流中包含的信息符合《Java
虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</strong></p>
<p>验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。</p>
<p>不过，验证阶段也不是必须要执行的阶段。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用
<code>-Xverify:none</code>
参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p>验证阶段主要由四个检验阶段组成：</p>
<ol type="1">
<li>文件格式验证（Class 文件格式检查）</li>
<li>元数据验证（字节码语义检查）</li>
<li>字节码验证（程序语义检查）</li>
<li>符号引用验证（类的正确性检查）</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403281149128.png"
alt="验证阶段示意图" />
<figcaption aria-hidden="true">验证阶段示意图</figcaption>
</figure>
<p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个
Java
类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p>
<blockquote>
<p>方法区属于是 JVM
运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析
Class
文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的
<strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
<p>关于方法区的详细介绍，推荐阅读 <a
href="https://javaguide.cn/java/jvm/memory-area.html">Java
内存区域详解open in new window</a> 这篇文章。</p>
</blockquote>
<p>符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM
将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。</p>
<p>符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM
会抛出异常，比如：</p>
<ul>
<li><code>java.lang.IllegalAccessError</code>：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li>
<li><code>java.lang.NoSuchFieldError</code>：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li>
<li><code>java.lang.NoSuchMethodError</code>：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。</li>
<li>……</li>
</ul>
<h2 id="准备">准备</h2>
<p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ol type="1">
<li>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被
<code>static</code>
关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在
Java 堆中。</li>
<li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong>
中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot
使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7
及之后，HotSpot
已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着
Class 对象一起存放在 Java 堆中。相关阅读：<a
href="https://github.com/fenixsoft/jvm_book/issues/75">《深入理解 Java
虚拟机（第 3 版）》勘误#75open in new window</a></li>
<li>这里所设置的初始值"通常情况"下是数据类型默认的零值（如
0、0L、null、false
等），比如我们定义了<code>public static int value=111</code> ，那么
value 变量在准备阶段的初始值就是 0 而不是
111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final
关键字<code>public static final int value=111</code> ，那么准备阶段
value 的值就被赋值为 111。</li>
</ol>
<p><strong>基本数据类型的零值</strong>：(图片来自《深入理解 Java
虚拟机》第 3 版 7.33 )</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403281150766.png"
alt="基本数据类型的零值" />
<figcaption aria-hidden="true">基本数据类型的零值</figcaption>
</figure>
<h2 id="解析">解析</h2>
<p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong>
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符
7 类符号引用进行。</p>
<p>《深入理解 Java 虚拟机》7.34
节第三版对符号引用和直接引用的解释如下：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403281150770.png"
alt="符号引用和直接引用" />
<figcaption aria-hidden="true">符号引用和直接引用</figcaption>
</figure>
<p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java
虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h2 id="初始化">初始化</h2>
<p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java
虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h2 id="类卸载">类卸载</h2>
<p><strong>卸载类即该类的 Class 对象被 GC。</strong></p>
<p>卸载类需要满足 3 个要求:</p>
<ol type="1">
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被 GC</li>
</ol>
<p>所以，在 JVM 生命周期内，由 jvm
自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>,
<code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK
提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock锁</title>
    <url>/2024/03/24/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>关于reentrantLock锁的一些问题</p>
</blockquote>
<span id="more"></span>
<h1 id="reentrantlock是什么">ReentrantLock是什么</h1>
<p><code>ReentrantLock</code> 实现了 <code>Lock</code>
接口，是一个可重入且独占式的锁，和 <code>synchronized</code>
关键字类似。不过，<code>ReentrantLock</code>
更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReentrantLock</code> 里面有一个内部类
<code>Sync</code>，<code>Sync</code> 继承
AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在
<code>Sync</code> 中实现的。<code>Sync</code> 有公平锁
<code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403251906294.png" /></p>
<p><code>ReentrantLock</code>
的特点是<strong>可重入</strong>，支持公平锁和非公平锁两种方式，从其构造方法就能看出，在传入参数为<code>true</code>时，<code>ReentrantLock</code>为公平锁，默认为非公平锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基于参数,创建FairSync还是NonFairSync</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>阅读<code>ReentrantLock</code>代码可知，它主要利用<code>CAS</code>+<code>AQS</code>
队列来实现。以非公平锁为例，当线程竞争锁时首先使用<code>CAS</code>抢占锁，成功则返回，失败则进入<code>AQS</code>队列并且挂起线程；当锁被释放时，唤醒<code>AQS</code>中的某个线程，从被挂起处再次尝试获取锁（当<code>AQS</code>队列头节点的下一个节点不为空时，直接唤醒该节点；否则从队尾向前遍历，找到最后一个不为空的节点并唤醒），获取锁失败则再次进入队尾。</p>
<h1 id="cas">CAS</h1>
<h2 id="学习cas首先了解什么是原子类">学习CAS首先了解什么是原子类</h2>
<p>即为java.util.concurrent.atomic包下的所有相关类和API</p>
<ul>
<li><p>没有CAS之前</p>
<p>多线程环境不使用原子类保证线程安全i++（基本数据类型）
常用synchronized锁，但是它比较重
，牵扯到了用户态和内核态的切换,效率不高。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入加锁保证原子性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用CAS之后</p>
<p>多线程情况下使用原子类保证线程安全（基本数据类型）</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入加锁保证原子性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//=================================</span></span><br><span class="line">    <span class="comment">//下面是新版本</span></span><br><span class="line">    <span class="comment">//=================================</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtomicInteger</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtomicInteger</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        atomicInteger.getAndIncrement();<span class="comment">//先读再加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cas是什么">CAS是什么</h2>
<h3 id="cas是什么-1">CAS是什么</h3>
<p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong>
，用于实现乐观锁，被广泛应用于各大框架中。CAS
的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
<p>执行CAS操作的时候，将内存位置的值与预期原值比较：
如果相匹配，那么处理器会自动将该位置值更新为新值，
如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。</p>
<blockquote>
<p><strong>原子操作</strong>
即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p>
</blockquote>
<p>CAS 涉及到三个操作数：</p>
<ul>
<li><strong>V</strong>：要更新的变量值(Var)</li>
<li><strong>E</strong>：预期值(Expected)</li>
<li><strong>N</strong>：拟写入的新值(New)</li>
</ul>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V
的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p>
<h2 id="cas的缺点">CAS的缺点</h2>
<h3 id="aba问题">ABA问题</h3>
<p>CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p>
<p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。</p>
<p>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的，因为在这段时间它的值可能被改为其他值，然后又改回
A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的
<strong>"ABA"问题。</strong>ABA
问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK
1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA
问题的，其中的 <code>compareAndSet()</code>
方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h3 id="循环时间长开销很大">循环时间长开销很大</h3>
<p>CAS
经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给
CPU 带来非常大的执行开销。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403251935720.png" /></p>
<h3
id="只能保证一个共享变量的原子操作">只能保证一个共享变量的原子操作</h3>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从
JDK 1.5
开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行
CAS
操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p>
<h1 id="aqs">AQS</h1>
<h2 id="aqs是什么">AQS是什么？</h2>
<p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code>
，翻译过来的意思就是抽象队列同步器。这个类在
<code>java.util.concurrent.locks</code> 包下面。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403251938892.png" /></p>
<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS
能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的
<code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如
<code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于
AQS 的。</p>
<h2 id="aqs的底层原理">AQS的底层原理</h2>
<p>AQS
核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制
AQS 是用 <strong>CLH 队列锁</strong>
实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH(Craig,Landin,and Hagersten)
队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS
是将每条请求共享资源的线程封装成一个 CLH
锁队列的一个结点（Node）来实现锁的分配。在 CLH
同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、
当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>
<p>CLH 队列结构如下图所示：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403251944422.png" /></p>
<p>AQS(<code>AbstractQueuedSynchronizer</code>)的核心原理图（图源<a
href="https://www.cnblogs.com/waterystone/p/4920797.html">Java 并发之
AQS 详解open in new window</a>）如下：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403251944878.png" /></p>
<ul>
<li>AQS使用一个int成员变量来表示同步状态</li>
<li>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置</li>
<li>AQS资源共享方式：独占Exclusive（排它锁模式）和共享Share（共享锁模式）</li>
</ul>
<hr />
<p>待续。。。</p>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java创建线程的方式</title>
    <url>/2024/03/23/Java/%E5%B9%B6%E5%8F%91/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>一些创建线程的方式</p>
</blockquote>
<span id="more"></span>
<h1 id="如何创建线程">如何创建线程</h1>
<p>一般来说，创建线程有很多种方式，例如继承<code>Thread</code>类、实现<code>Runnable</code>接口、实现<code>Callable</code>接口、使用线程池、使用<code>CompletableFuture</code>类等等。</p>
<p>不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在
Java 代码中使用多线程的方法。</p>
<p>严格来说，Java
就只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p>
<h2 id="继承tread类">继承Tread类</h2>
<p>这是最普通的方式，继承<code>Thread</code>类，重写<code>run</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ExtendsThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现runnable接口">实现Runnable接口</h3>
<p>这也是一种常见的方式，实现<code>Runnable</code>接口并重写<code>run</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImplementsRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ImplementsRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplementsRunnable</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与继承<code>Thread</code>接口不同的是，Java当中是单继承，当一个类继承了<code>Thread</code>类后就无法再继承其他的类，通过实现<code>Runnable</code>接口并重写<code>run</code>方法，可以再实现继承其他类。</p>
<h3 id="实现callable接口">实现Callable接口</h3>
<p>和上一种方式类似，这里需要去重写<code>Callable</code>接口的<code>call</code>方法，并配合<code>FutureTask</code>使用，只不过这种方式可以使用<code>get()</code>方法拿到线程执行完的返回值，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImplementsCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3......&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Justin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ImplementsCallable</span> <span class="variable">callable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplementsCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用executorservice线程池">使用ExecutorService线程池</h3>
<p>这种属于进阶方式，可以通过<code>Executors</code>创建线程池，也可以自定义线程池，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseExecutorService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">poolA</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        poolA.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;4A......&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        poolA.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 又或者自定义线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">poolB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        poolB.submit(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;4B......&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        poolB.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意点">注意点</h2>
<p>创建线程的方式十分多样，最少都能有上面的四种答案，那这真的对吗？可以说对，但严格意义上来说，又不对。</p>
<p>抛开后面一些先不谈，咱们就聊最开始的三种：“继承<code>Thread</code>类、实现<code>Runnable</code>接口、实现<code>Callable</code>接口”，这应该是广为人知的答案。</p>
<p>那么此时来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImplementsRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">&quot;：小猫爱吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个类，实现了<code>Runnable</code>接口并重写了<code>run</code>方法，按前面的说法，这种方式是不是创建了一条线程？答案是<code>Yes</code>，可问题来了，请你告诉我，该如何启动这条所谓的“线程”呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ImplementsRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplementsRunnable</span>();</span><br><span class="line">    runnable.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>难道像上面这样嘛？来看看运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main：小猫爱吃鱼</span><br></pre></td></tr></table></figure>
<p>结果很显然，打印出的线程名字为：<code>main</code>，代表目前是主线程在运行，和调用普通方法没任何区别，那究竟该如何创建一条线程呀？要这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ImplementsRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplementsRunnable</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先<code>new</code>出<code>Runnable</code>对象，接着再<code>new</code>一个<code>Thread</code>对象，然后把<code>Runnable</code>丢给<code>Thread</code>，接着调用<code>start()</code>方法，此时才能真正意义上创建一条线程，运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0：小猫爱吃鱼</span><br></pre></td></tr></table></figure>
<p>此时线程名字变成了<code>Thread-0</code>，这意味着输出“小猫爱吃鱼”这句话的代码，并不是<code>main</code>线程在执行了，实现了<code>Runnable</code>接口的<code>ImplementsRunnable</code>类，并不能被称为一条线程，包括所谓的<code>Callable、FutureTask……</code>，都不能创建出真正的线程。</p>
<p>换到前面所提出的三种方式中，只有继承<code>Thread</code>类，才能真正创建一条线程，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">&quot;：小猫爱吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ExtendsThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">//      Thread-0：竹子爱熊猫</span></span><br></pre></td></tr></table></figure>
<p>因为当你用一个类，继承<code>Thread</code>类时，它内部所有的方法，都会被继承过来，所以当前类可以直接调用<code>start()</code>方法启动，更具体点来说，<strong>在<code>Java</code>中，创建线程的方式就只有一种：调用<code>Thread.start()</code>方法</strong>！只有这种形式，才能在真正意义上创建一条线程！</p>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>Java当中的各种锁</title>
    <url>/2024/03/23/Java/%E5%B9%B6%E5%8F%91/Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>15种锁！</p>
</blockquote>
<span id="more"></span>
<h1 id="乐观锁">乐观锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232110652.png" alt="image-20240323210351234" style="zoom: 67%;" /></p>
<p><strong>乐观锁是一种乐观思想</strong>，假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改（所以没有上锁）。写数据时，判断当前与期望值是否相同，如果相同则进行更新（更新期间加锁，保证是原子性的）。</p>
<p>即假设数据修改不会造成冲突，在数据提交更新时才进行冲突检测。</p>
<p><strong>Java中的乐观锁：</strong>
CAS，比较并替换，比较当前值（主内存中的值），与预期值（当前线程中的值，主内存中值的一份拷贝）是否一样，一样则更新，否则继续进行CAS操作。</p>
<p>如上图所示，可以同时进行读操作，读的时候其他线程不能进行写操作。</p>
<h1 id="悲观锁">悲观锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232110830.png" alt="image-20240323210903997" style="zoom: 67%;" /></p>
<p><strong>悲观锁是一种悲观思想</strong>，即认为写多读少，遇到并发写的可能性高，每次去拿数据的时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程block，直到这个线程释放锁然后其他线程获取到锁。</p>
<p>即数据修改前，假设一定会发生冲突，先尝试为它加锁。</p>
<p><strong>Java中的悲观锁：</strong>
synchronized修饰的方法和方法块、ReentrantLock。</p>
<p>如上图所示，只能有一个线程进行读操作或者写操作，其他线程的读写操作均不能进行。</p>
<h1 id="自旋锁">自旋锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232110895.png" alt="image-20240323211029664" style="zoom: 67%;" /></p>
<p><strong>自旋锁是一种技术：</strong>
为了让线程等待，我们只须让线程执行一个忙循环（自旋）。</p>
<p>现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p><strong>自旋锁的优点：</strong>
避免了线程切换的开销。挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。</p>
<p><strong>自旋锁的缺点：</strong>
占用处理器的时间，如果占用的时间很长，会白白消耗处理器资源，而不会做任何有价值的工作，带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。</p>
<p>自旋次数默认值：10次，可以使用参数<code>-XX:PreBlockSpin</code>来自行更改。</p>
<p><strong>自适应自旋：</strong>
自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越精准。</p>
<p><strong>Java中的自旋锁：</strong>
CAS操作中的比较操作失败后的自旋等待。</p>
<h1 id="可重入锁">可重入锁</h1>
<p><strong>可重入锁是一种技术：</strong>
任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。</p>
<p><strong>可重入锁的原理：</strong> 为每个锁关联一个计数器。</p>
<ul>
<li>首次获取锁：计数器置为1.</li>
<li>再次获取锁：计数器加1</li>
<li>释放锁：释放锁时，进行计数自减。计数器为0则代表锁被当前线程释放。</li>
</ul>
<p><strong>Java中的可重入锁：</strong>
ReentrantLock、synchronized修饰的方法或代码段。</p>
<p><strong>可重入锁的作用：</strong> 避免死锁。</p>
<p><strong>面试题1：</strong>
可重入锁如果加了两把，但是只释放了一把会出现什么问题？</p>
<p>答：程序卡死，线程不能出来，也就是说我们申请了几把锁，就需要释放几把锁。</p>
<p><strong>面试题2：</strong>
如果只加了一把锁，释放两次会出现什么问题？</p>
<p>答：会报错，java.lang.IllegalMonitorStateException。</p>
<h1 id="读写锁">读写锁</h1>
<p><strong>读写锁是一种技术：</strong>
通过ReentrantReadWriteLock类来实现。为了提高性能， Java
提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由
jvm 自己控制的。</p>
<p><strong>读锁：</strong>
允许多个线程获取读锁，同时访问同一个资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232116006.png" alt="image-20240323211616975" style="zoom:67%;" /></p>
<p><strong>写锁：</strong>
只允许一个线程获取写锁，不允许同时访问同一个资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232116455.png" alt="image-20240323211655063" style="zoom:67%;" /></p>
<p><strong>Java中的读写锁：</strong>ReentrantReadWriteLock</p>
<h1 id="公平锁">公平锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232120587.png" alt="image-20240323211822932" style="zoom:67%;" /></p>
<p><strong>公平锁是一种思想：</strong>
多个线程竞争锁时直接进入队列排队，按照申请锁的顺序来获取锁，先到先得。在并发环境中，每个线程会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，如果等待队列不为空，则加入到等待队列的末尾，按照FIFO的原则从队列中拿到线程，然后占有锁。</p>
<h1 id="非公平锁">非公平锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232121397.png" alt="image-20240323212125844" style="zoom:67%;" /></p>
<p><strong>非公平锁是一种思想：</strong>
多个线程竞争锁时，线程先尝试获取锁，如果获取不到，则再采用公平锁的方式，进入等待队列。多个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的线程优先获取锁。</p>
<p><strong>优点：</strong> 非公平锁的性能高于公平锁。</p>
<p><strong>缺点：</strong>
有可能造成线程饥饿（某个线程很长一段时间获取不到锁）</p>
<p><strong>Java中的非公平锁：</strong>synchronized是非公平锁，ReentrantLock通过构造函数指定该锁是公平的还是非公平的，默认是非公平的。</p>
<h1 id="共享锁">共享锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232122441.png" alt="image-20240323212253082" style="zoom:67%;" /></p>
<p><strong>共享锁是一种思想：</strong>
可以有多个线程获取读锁，以共享的方式持有锁。和乐观锁、读写锁同义。</p>
<p><strong>Java中用到的共享锁：</strong> ReentrantReadWriteLock。</p>
<h1 id="独占锁">独占锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232123222.png" alt="image-20240323212332680" style="zoom:67%;" /></p>
<p><strong>独占锁是一种思想：</strong>
只能有一个线程获取锁，以独占的方式持有锁。和悲观锁、互斥锁同义。</p>
<p><strong>Java中用到的独占锁：</strong> synchronized，ReentrantLock</p>
<h1 id="重量级锁">重量级锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232124347.png" alt="image-20240323212424987" style="zoom:67%;" /></p>
<p><strong>重量级锁是一种称谓：</strong>
synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本身依赖底层的操作系统的
Mutex
Lock来实现。操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系统
Mutex
Lock来实现的锁称为重量级锁。为了优化synchonized，引入了轻量级锁，偏向锁。</p>
<p><strong>Java中的重量级锁：</strong> synchronized</p>
<h1 id="轻量级锁">轻量级锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232125738.png" alt="image-20240323212543336" style="zoom:67%;" /></p>
<p><strong>轻量级锁是JDK6时加入的一种锁优化机制：</strong>
轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。轻量级是相对于使用操作系统互斥量来实现的重量级锁而言的。轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁将不会有效，必须膨胀为重量级锁。</p>
<p><strong>优点：</strong>
如果没有竞争，通过CAS操作成功避免了使用互斥量的开销。</p>
<p><strong>缺点：</strong>
如果存在竞争，除了互斥量本身的开销外，还额外产生了CAS操作的开销，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。</p>
<h1 id="偏向锁">偏向锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232127632.png" alt="image-20240323212744980" style="zoom:67%;" /></p>
<p><strong>偏向锁是JDK6时加入的一种锁优化机制：</strong>
在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。偏是指偏心，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark
Word的更新操作等）。</p>
<p><strong>优点：</strong>
把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁。</p>
<p><strong>缺点：</strong>
如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的。</p>
<h1 id="分段锁">分段锁</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232129274.png" alt="image-20240323212928660" style="zoom:67%;" /></p>
<p><strong>分段锁是一种机制：</strong>
最好的例子来说明分段锁是ConcurrentHashMap。<strong>ConcurrentHashMap原理：</strong>它内部细分了若干个小的
HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap
被进一步细分为 16 个段，既就是锁的并发度。如果需要在 ConcurrentHashMap
添加一项key-value，并不是将整个 HashMap 加锁，而是首先根据 hashcode
得到该key-value应该存放在哪个段中，然后对该段加锁，并完成 put
操作。在多线程环境中，如果多个线程同时进行put操作，只要被加入的key-value不存放在同一个段中，则线程间可以做到真正的并行。</p>
<p><strong>线程安全：</strong>ConcurrentHashMap 是一个 Segment 数组，
Segment 通过继承ReentrantLock
来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个
Segment 是线程安全的，也就实现了全局的线程安全</p>
<h1 id="锁粗化">锁粗化</h1>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232135180.png" alt="image-20240323213547009" style="zoom:67%;" /></p>
<p><strong>锁粗化是一种优化技术：</strong>
如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步操作将会导致不必要的性能损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗。</p>
<h2 id="锁消除">锁消除</h2>
<p><img src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232136997.png" alt="image-20240323213626287" style="zoom:67%;" /></p>
<p><strong>锁消除是一种优化技术：</strong>
就是把锁干掉。当Java虚拟机运行时发现有些共享数据不会被线程竞争时就可以进行锁消除。</p>
<p>那如何判断共享数据不会被线程竞争？</p>
<p>利用逃逸分析技术：分析对象的作用域，如果对象在A方法中定义后，被作为参数传递到B方法中，则称为方法逃逸；如果被其他线程访问，则称为线程逃逸。</p>
<p>在堆上的某个数据不会逃逸出去被其他线程访问到，就可以把它当作栈上数据对待，认为它是线程私有的，同步加锁就不需要了。</p>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2024/03/27/Java/%E5%B9%B6%E5%8F%91/ThreadLocal/</url>
    <content><![CDATA[<blockquote>
<p>ThreadLocal相关</p>
</blockquote>
<span id="more"></span>
<h1 id="threadlocal有什么用">ThreadLocal有什么用</h1>
<p><code>ThreadLocal</code>为每个使用该变量的线程提供一个副本，每个线程都可以独立修改自己的副本，而不会与其他线程的副本产生冲突。</p>
<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>
<p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。
<strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用
<code>get()</code> 和 <code>set()</code>
方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么
ThreadLocal 就是用来避免这两个线程竞争的。</p>
<h1 id="threadlocal-内存泄露是怎么回事">ThreadLocal
内存泄露是怎么回事</h1>
<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code>
的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code>
没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value
不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的
Entry。假如我们不做任何措施的话，value 永远无法被 GC
回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code>
实现中已经考虑了这种情况，在调用
<code>set()</code>、<code>get()</code>、<code>remove()</code>
方法的时候，会清理掉 key 为 null 的记录。使用完
<code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它
所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，
因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java
虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized锁</title>
    <url>/2024/03/25/Java/%E5%B9%B6%E5%8F%91/synchronized%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>关于synchronized锁的一些问题</p>
</blockquote>
<span id="more"></span>
<h1 id="什么是synchronized锁">什么是synchronized锁</h1>
<blockquote>
<p>官方：同步方法支持一种简单的策略来防止线程受到干扰和内存一致性错误；如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成</p>
</blockquote>
<p>通俗点来说就是程序中用于保护线程安全的一种机制。</p>
<h1 id="底层原理">底层原理</h1>
<p>在<code>HotSpot</code>虚拟机中，对象内存布局主要分为对象头（<strong>Header</strong>）、示例数据（<strong>Instance
Data</strong>）和对齐填充（<strong>Padding</strong>）。</p>
<p><strong>对象头 = Mark Word + 类型指针（</strong>Klass
pointer<strong>）。</strong></p>
<p><strong>类型指针（</strong>Klass pointer<strong>）</strong> ：
用于标识JVM通过这个指针来确定这个对象是哪个类的实例。</p>
<p><strong>Mark Word</strong> ：
用于储存对象自身的运行时数据，例如对象的hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程的ID、偏向时间戳等。<strong>在运行期间，Mark
Word里存储的数据会随着内部锁标志位的变化而变化。</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403251959954.png" /></p>
<p><strong>无锁状态(01)</strong></p>
<p>对象头开辟 25bit 的空间用来存储对象的 hashcode ，4bit
用于存放分代年龄，1bit 用来存放是否偏向锁的标识位，2bit
用来存放锁标识位为01。</p>
<p><strong>偏向锁状态(01)</strong></p>
<p>还是开辟25bit 的空间，其中23bit 用来存放线程ID，2bit 用来存放
epoch，4bit 存放分代年龄，1bit 存放是否偏向锁标识，
0表示无锁，1表示偏向锁，锁的标识位还是01。</p>
<p><strong>轻量级锁状态(00)</strong></p>
<p>开辟 30bit 的空间存放指向<strong>栈中锁记录</strong>的指针，2bit
存放锁的标志位，其标志位为00。</p>
<p><strong>重量级锁状态(10)</strong></p>
<p>30bit 的空间用来存放指向<strong>重量级锁</strong>的指针，2bit
存放锁的标识位，为10。</p>
<p><strong>GC标记(11)</strong></p>
<p>开辟30bit 的内存空间却没有占用，2bit 空间存放锁标志位为11。</p>
<p>之所以这些标志位会变化，是JVM对重量级锁的一种优化，在jdk1.6
之前，用synchronized 都是重量级锁 ，都需要底层操作系统的Mutex
Lock（互斥锁）来实现，这个是涉及到系统调用的，会导致内核空间与用户空间的上下文切换，很低效。</p>
<p>于是jdk1.6之后为了增加性能减少操作Mutex
Lock，引入了<code>偏向锁</code>和<code>轻量级锁</code>：锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。</p>
<h3 id="锁升级过程">锁升级过程</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 临界区之前</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">  <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 临界区之后</span></span><br></pre></td></tr></table></figure>
<h3 id="无锁">无锁</h3>
<p>当有线程进入临界区之前(synchronized块之前)，lock里的对象头的 Mark
Word 结构为下面所示：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403252000225.webp" /></p>
<p>锁标志位01，无偏向。这是JVM给的初始值。</p>
<h3 id="偏向锁">偏向锁</h3>
<p>有<strong>线程A</strong>刚进入临界区时(synchronized)，发现标志位是01
，而且无偏向。立马把当前线程ID记录到了这个Mark
Word当中，修改为偏向（1）。也就是下面这样：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403252000323.webp" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403252001168.webp" /></p>
<p>如果线程A，再次进入临界区时 ， 判断线程id
是当前自己，就直接执行。也就是说，如果一直没有其它线程过来，线程A就跟没加synchronized一样执行，效率极高。这就是<strong>偏向锁</strong>。</p>
<h3 id="轻量级锁">轻量级锁</h3>
<p>当有其它<strong>线程B</strong>
也进入临界区了(线程A还没出临界区)，就CAS自旋等待很短的时间，如果线程A此时恰好退出临界区了，CAS退出就升级为轻量级锁，否则就是重量级锁。
轻量级锁会构造一个Lock Record锁记录，如下图：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403252001772.webp" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403252001283.webp" /></p>
<p><strong>Lock Record 锁记录</strong></p>
<p>Lock Record是线程私有的数据结构，每一个线程都有一个可用Lock
Record列表，同时还有一个全局的可用列表。每一个被锁住的对象Mark
Word都会和一个Lock Record关联（对象头的MarkWord中的Lock Word指向Lock
Record的起始地址），同时Lock
Record中有一个Owner字段存放拥有该锁的线程的唯一标识（或者<code>object mark word</code>），表示该锁被这个线程占用。如下图所示为Lock
Record的内部结构：</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Lock Record</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Owner</td>
<td>初始时为NULL表示当前没有任何线程拥有该monitor
record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</td>
</tr>
<tr class="even">
<td>EntryQ</td>
<td>关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor
record失败的线程；</td>
</tr>
<tr class="odd">
<td>RcThis</td>
<td>表示blocked或waiting在该monitor record上的所有线程的个数；</td>
</tr>
<tr class="even">
<td>Nest</td>
<td>用来实现 重入锁的计数；</td>
</tr>
<tr class="odd">
<td>HashCode</td>
<td>保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</td>
</tr>
<tr class="even">
<td>Candidate</td>
<td>用来避免不必要的阻塞或等待线程唤醒ngjio，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</td>
</tr>
</tbody>
</table>
<p><strong>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，必然就会导致轻量级锁膨胀为重量级锁</strong>。</p>
<h3 id="重量级锁">重量级锁</h3>
<p>Synchronized是通过对象内部的一个叫做
<strong>监视器锁（Monitor）来实现的</strong>。<strong>但是监视器锁本质又是依赖于底层的操作系统的Mutex
Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间</strong>，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex
Lock所实现的锁我们称之为 <strong>“重量级锁”</strong>。</p>
<p>重量级锁的Mark Word结构图：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403252001075.webp" /></p>
<p>这个重量级锁的指针指向的就是 <strong>ObjectMonitor</strong> 。</p>
<h3 id="锁升级图">锁升级图</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403252004741.JPG" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403252004026.JPG" /></p>
<p>图源：收割Offer：互联网大厂面经——布兜</p>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字</title>
    <url>/2024/03/23/Java/%E5%B9%B6%E5%8F%91/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<blockquote>
<p>关于synchronized关键字的一些问题</p>
</blockquote>
<span id="more"></span>
<h1 id="synchronized是什么有什么用">synchronized是什么？有什么用？</h1>
<p><code>synchronized</code> 是 Java
中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>在 Java 早期版本中，<code>synchronized</code> 属于
<strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的
<code>Mutex Lock</code> 来实现的，Java
的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>不过，在 Java 6 之后， <code>synchronized</code>
引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让
<code>synchronized</code> 锁的效率提升了很多。因此，
<code>synchronized</code> 还是可以在实际项目中使用的，像 JDK
源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p>
<p>关于偏向锁多补充一点：由于偏向锁增加了 JVM
的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK15
中，偏向锁被默认关闭（仍然可以使用 <code>-XX:+UseBiasedLocking</code>
启用偏向锁），在 JDK18
中，偏向锁已经被彻底废弃（无法通过命令行打开）。</p>
<h1 id="如何使用synchronized">如何使用synchronized？</h1>
<p><code>synchronized</code> 关键字的使用方式主要有下面 3 种：</p>
<ol type="1">
<li>修饰实例方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ol>
<p><strong>1、修饰实例方法</strong> （锁当前对象实例）</p>
<p>给当前对象实例加锁，进入同步代码前要获得
<strong>当前对象实例的锁</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、修饰静态方法</strong> （锁当前类）</p>
<p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得
<strong>当前 class 的锁</strong>。</p>
<p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code>
方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态
<code>synchronized</code> 方法，而线程 B
需要调用这个实例对象所属类的静态 <code>synchronized</code>
方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code>
方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code>
方法占用的锁是当前实例对象锁。</p>
<p><strong>3、修饰代码块</strong> （锁指定对象/类）</p>
<p>对括号里指定的对象/类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得
<strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得
<strong>给定 Class 的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和
<code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li>
<li><code>synchronized</code>
关键字加到实例方法上是给对象实例上锁；</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM
中，字符串常量池具有缓存功能。</li>
</ul>
<h1
id="构造方法可以用synchronized修饰吗">构造方法可以用synchronized修饰吗？</h1>
<p>先说结论：<strong>构造方法不能使用 synchronized
关键字修饰。</strong></p>
<p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<h1 id="synchronized底层原理">synchronized底层原理</h1>
<h2 id="synchronized同步语句块的情况">synchronized同步语句块的情况</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 JDK 自带的 <code>javap</code> 命令查看
<code>SynchronizedDemo</code>
类的相关字节码信息：首先切换到类的对应目录执行
<code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class
文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403241719285.png"
alt="synchronized关键字原理" />
<figcaption aria-hidden="true">synchronized关键字原理</figcaption>
</figure>
<p>从上面我们可以看出：<strong><code>synchronized</code>
同步语句块的实现使用的是 <code>monitorenter</code> 和
<code>monitorexit</code> 指令，其中 <code>monitorenter</code>
指令指向同步代码块的开始位置，<code>monitorexit</code>
指令则指明同步代码块的结束位置。</strong></p>
<p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个
<code>monitorexit</code>
指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。它在底层使用了隐式的try
- finally，以防正常代码在执行过程中抛了异常。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取
<strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p><code>Monitor</code>被翻译为监视器，是由<code>jvm</code>提供，<code>C++</code>语言实现。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403241632387.png"
alt="image-20240324163226315" />
<figcaption aria-hidden="true">image-20240324163226315</figcaption>
</figure>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为
0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403241633580.png"
alt="执行 monitorenter 获取锁" />
<figcaption aria-hidden="true">执行 monitorenter 获取锁</figcaption>
</figure>
<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code>
指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为
0，表明锁被释放，其他线程可以尝试获取锁。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403241634558.png"
alt="执行 monitorexit 释放锁" />
<figcaption aria-hidden="true">执行 monitorexit 释放锁</figcaption>
</figure>
<p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h2 id="synchronized修饰方法的情况">synchronized修饰方法的情况</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://oss.javaguide.cn/github/javaguide/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png"
alt="synchronized关键字原理" />
<figcaption aria-hidden="true">synchronized关键字原理</figcaption>
</figure>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code>
指令和 <code>monitorexit</code> 指令，取得代之的确实是
<code>ACC_SYNCHRONIZED</code>
标识，该标识指明了该方法是一个同步方法。JVM 通过该
<code>ACC_SYNCHRONIZED</code>
访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM
会尝试获取当前 class 的锁。</p>
<h2 id="总结">总结</h2>
<p><code>synchronized</code> 同步语句块的实现使用的是
<code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中
<code>monitorenter</code>
指令指向同步代码块的开始位置，<code>monitorexit</code>
指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code>
指令和 <code>monitorexit</code> 指令，取得代之的确实是
<code>ACC_SYNCHRONIZED</code>
标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403241643733.png"
alt="image-20240324164351101" />
<figcaption aria-hidden="true">image-20240324164351101</figcaption>
</figure>
<h1
id="jdk1.6后的synchronized底层做了哪些优化锁升级原理">JDK1.6后的synchronized底层做了哪些优化？锁升级原理？</h1>
<p>在 Java 6 之后， <code>synchronized</code>
引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让
<code>synchronized</code> 锁的效率提升了很多（JDK18
中，偏向锁已经被彻底废弃，前面已经提到过了）。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p><code>synchronized</code>
锁升级是一个比较复杂的过程，面试也很少问到，如果你想要详细了解的话，可以看看这篇文章：<a
href="https://www.cnblogs.com/star95/p/17542850.html">浅析 synchronized
锁升级的原理与实现</a></p>
<h1
id="synchronized和volatile有什么区别">synchronized和volatile有什么区别</h1>
<p><code>synchronized</code> 关键字和 <code>volatile</code>
关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以
<code>volatile</code>性能肯定比<code>synchronized</code>关键字要好
。但是 <code>volatile</code> 关键字只能用于变量而
<code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code>
关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code>
关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而
<code>synchronized</code>
关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字</title>
    <url>/2024/03/23/Java/%E5%B9%B6%E5%8F%91/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<blockquote>
<p>关于volatile关键字的一些问题</p>
</blockquote>
<span id="more"></span>
<h1 id="java内存模型是什么">Java内存模型是什么</h1>
<p>如下面两张图所示（这里JavaGuide画的图就很好，直接拿来了，侵删），变量是放在主存中的，每个线程都有自己的工作内存（本地内存），线程运行时将主存中的数据复制到工作内存当中，对数据的任何操作都是基于自己的工作内存进行的，之后再将更新后的数据刷新到主存。</p>
<p><strong>当前线程不能直接操作主存和其他线程工作内存中的数据。</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232024135.png"
alt="JMM(Java 内存模型)" />
<figcaption aria-hidden="true">JMM(Java 内存模型)</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403232024275.png"
alt="JMM(Java 内存模型)强制在主存中进行读取" />
<figcaption aria-hidden="true">JMM(Java
内存模型)强制在主存中进行读取</figcaption>
</figure>
<h1 id="volatile关键字的作用">volatile关键字的作用</h1>
<p><strong>volatile关键字保证了变量的立即可见性</strong></p>
<p><code>线程A</code>与<code>线程B</code>并发运行时可能出现这种情况，如果<code>线程A</code>修改了工作内存中的数据且还未同步到主存，那么<code>线程B</code>读取的主存中的数据就不是最新值。当变量被volatile关键字修饰后，任何线程对它的写操作都会强制将工作内存中的最新值刷新到主存，同时使其他线程工作内存中的变量缓存无效，这样其他线程使用缓存时就会重新到主存中读取最新值。</p>
<p>即如果我们将变量声明为 <strong><code>volatile</code></strong>
，这就指示
JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p><strong><code>volatile</code>
关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code>
关键字两者都能保证。</strong></p>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2024/03/27/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<blockquote>
<p>线程池相关问题</p>
</blockquote>
<span id="more"></span>
<h1 id="什么是线程池">什么是线程池</h1>
<p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403272230408.png"
alt="管理线程的池子" />
<figcaption aria-hidden="true">管理线程的池子</figcaption>
</figure>
<h1 id="为什么要用线程池">为什么要用线程池</h1>
<p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率，线程池、数据库连接池、HTTP
连接池等等都是对这个思想的应用。</p>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。
每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java
并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h1 id="如何创建线程池">如何创建线程池</h1>
<h2
id="方式一通过threadpoolexcutor构造函数来创建推荐">方式一：通过<code>ThreadPoolExcutor</code>构造函数来创建（推荐）</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403272237184.png"
alt="通过构造方法实现" />
<figcaption aria-hidden="true">通过构造方法实现</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403272243671.png"
alt="构造参数" />
<figcaption aria-hidden="true">构造参数</figcaption>
</figure>
<p>从图中可知，<code>ThreadPoolExecutor</code>的构造参数有
<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>keepAliveTime</code>、<code>unit</code>、<code>workQueue</code>、<code>threadFactory</code>、<code>handler</code>。</p>
<p><strong>corePoolSize</strong>:
核心线程池的大小。这是线程池中保持活动的最小线程数。即使线程处于空闲状态，核心线程也不会被终止。如果线程池中的线程数小于这个值，则线程池会创建新的线程。
<strong>maximumPoolSize</strong>:
线程池能够容纳的最大线程数。如果线程池中的线程数超过这个值，则任务将被阻塞。如果线程池中的线程在一段时间内没有执行任务，它们将被终止。
<strong>keepAliveTime</strong>:
非核心线程（数量超过<code>corePoolSize</code>的线程）的空闲时间。如果一个非核心线程空闲时间超过这个值，且线程数超过<code>corePoolSize</code>，则这个线程会被终止。
<strong>unit</strong>:
<code>keepAliveTime</code>的时间单位。可以是<code>TimeUnit</code>的枚举值，如<code>TimeUnit.SECONDS</code>，<code>TimeUnit.MILLISECONDS</code>等。
<strong>workQueue</strong>:
任务队列。它存储提交但尚未执行的任务。这个参数是可选的，如果没有提供，则使用无界队列。
<strong>threadFactory</strong>:
用于创建新线程的工厂。它用于定义新线程的名称和其它一些属性。
<strong>handler</strong>:
当任务队列已满并且核心线程数已满时，这个处理器将处理无法执行的任务。它定义了如何拒绝多余的任务。</p>
<h1 id="方式二通过-executor-框架的工具类-executors-来创建">方式二：通过
<code>Executor</code> 框架的工具类 <code>Executors</code> 来创建</h1>
<p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p>
<ul>
<li><strong><code>FixedThreadPool</code></strong>：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>：</strong>
该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong><code>CachedThreadPool</code>：</strong>
该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为
0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为
60
秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li>
<li><strong><code>ScheduledThreadPool</code></strong>：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li>
</ul>
<p>对应 <code>Executors</code> 工具类中的方法如图所示：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403272259339.png" /></p>
<h1 id="为什么不推荐使用内置线程池">为什么不推荐使用内置线程池</h1>
<p>在《阿里巴巴 Java
开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>
<p><strong>为什么呢？</strong></p>
<blockquote>
<p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</blockquote>
<p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用
<code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code>
构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和
<code>SingleThreadExecutor</code></strong>:使用的是无界的
<code>LinkedBlockingQueue</code>，任务队列最大长度为
<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code></strong>:使用的是同步队列
<code>SynchronousQueue</code>, 允许创建的线程数量为
<code>Integer.MAX_VALUE</code>
，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致
OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和
<code>SingleThreadScheduledExecutor</code></strong>:使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为
<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无界队列 LinkedBlockingQueue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无界队列 LinkedBlockingQueue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span> (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE`</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DelayedWorkQueue（延迟阻塞队列）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如何设置线程池的核心线程数量">如何设置线程池的核心线程数量</h1>
<p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU
资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU
核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU
就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU
的空闲时间。</p>
<p><strong>I/O 密集型任务(2N)：</strong>
这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O
的时间段内不会占用 CPU 来处理，这时就可以将 CPU
交出给其它线程使用。因此在 I/O
密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N</p>
<p>这是一个不会错得很离谱的经验值，由于应用中可能存在多个线程池，以及具体场景的不同，因此合理的线程数需要压测才能决定。</p>
<h1 id="线程池的状态和生命周期">线程池的状态和生命周期</h1>
<p>线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403272307386.png"
alt="线程池状态切换图" />
<figcaption aria-hidden="true">线程池状态切换图</figcaption>
</figure>
<p><strong>RUNNING</strong></p>
<ul>
<li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li>
<li>调用线程池的 shutdown()方法，可以切换到 SHUTDOWN 状态;</li>
<li>调用线程池的 shutdownNow()方法，可以切换到 STOP 状态;</li>
</ul>
<p><strong>SHUTDOWN</strong></p>
<ul>
<li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li>
<li>队列为空，并且线程池中执行的任务也为空,进入 TIDYING 状态;</li>
</ul>
<p><strong>STOP</strong></p>
<ul>
<li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li>
<li>线程池中执行的任务为空,进入 TIDYING 状态;</li>
</ul>
<p><strong>TIDYING</strong></p>
<ul>
<li>该状态表明所有的任务已经运行终止，记录的任务数量为 0。</li>
<li>terminated()执行完毕，进入 TERMINATED 状态</li>
</ul>
<p><strong>TERMINATED</strong></p>
<ul>
<li>该状态表示线程池彻底终止</li>
</ul>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收机制</title>
    <url>/2024/03/25/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>关于JVM的垃圾回收机制的一些问题</p>
</blockquote>
<span id="more"></span>
<h1 id="什么样的对象是垃圾">什么样的对象是垃圾？</h1>
<p>如果一个对象不会再被引用了，那么这个对象就是垃圾。</p>
<h1 id="如何判断垃圾垃圾判断算法">如何判断垃圾（垃圾判断算法）</h1>
<h2 id="引用计数法">引用计数法</h2>
<p>引用计数法为每个对象引入计数器，当对象被引用时计数器加1，当引用失效时计数器减1，计数器为0的话则表示这个对象不可达，即为垃圾。</p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403252244399.png"
alt="对象之间循环引用" />
<figcaption aria-hidden="true">对象之间循环引用</figcaption>
</figure>
<p>这样其他对象都不会引用这两个对象，但因为这两个对象互相引用，所以计数器永远不会为0，垃圾无法被回收，所以我们一般不使用这个回收算法。</p>
<h2 id="可达性分析算法">可达性分析算法</h2>
<p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong>
的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到
GC Roots
没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403252253483.png"
alt="可达性分析算法" />
<figcaption aria-hidden="true">可达性分析算法</figcaption>
</figure>
<p>如上图土黄色的对象就是<code>GC Roots</code>可达的，绿色标记的对象间虽然有引用关系，但它们，<code>GC Roots</code>不可达，所以需要被回收。</p>
<h3 id="可作为gc-roots的对象">可作为GC Roots的对象</h3>
<ul>
<li>虚拟机栈引用的对象</li>
<li>本地方法栈引用的对象</li>
<li>静态成员引用的对象</li>
<li>常量引用的对象</li>
</ul>
<p>引用类型总结请看<a href="https://javaguide.cn/">JavaGuide</a>的总结<a
href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95">引用类型总结</a></p>
<h1 id="stop-the-world">Stop The World</h1>
<p>"Stop The World"是 Java 垃圾收集中的一个重要概念，通常简写为
<strong>STW</strong>。在垃圾收集过程中，JVM
会暂停所有的用户线程，这种暂停被称为"Stop The World"事件。</p>
<p>这么做的主要原因是为了防止在垃圾收集过程中，用户线程修改了堆中的对象，导致垃圾收集器无法准确地收集垃圾。</p>
<p>值得注意的是，"Stop The World"事件会对 Java
应用的性能产生影响。如果停顿时间过长，就会导致应用的响应时间变长，对于对实时性要求较高的应用，如交易系统、游戏服务器等，这种情况是不能接受的。</p>
<p>因此，在选择和调优垃圾收集器时，需要考虑其停顿时间。Java
中的一些垃圾收集器，如 G1 和 ZGC，都会尽可能地减少了"Stop The
World"的时间，通过并发的垃圾收集，提高应用的响应性能。</p>
<p>总的来说，"Stop The World"是 Java
垃圾收集中必须面对的一个挑战，其目标是在保证内存的有效利用和应用的响应性能之间找到一个平衡。</p>
<h1
id="如何标记需要回收的垃圾三色标记算法">如何标记需要回收的垃圾（三色标记算法）</h1>
<h2 id="三色标记算法是什么">三色标记算法是什么</h2>
<p>三色标记算法是一种常见的垃圾收集的标记算法，属于根可达算法的一个分支，垃圾收集器CMS，G1在标记垃圾过程中就使用该算法。</p>
<h3 id="什么是三色">什么是三色</h3>
<p>三色指的是白色，灰色，黑色（white，gray，black）。抽象的理解，可以认为垃圾收集器在标记阶段将对象染成不同的颜色，根据不同的颜色做不同处理。那么三种染色的对象分别指什么呢？</p>
<ul>
<li>白色：未被扫描到的对象，可达性分析后最终为白色的对象就是垃圾对象（在标记开始时堆内存中的对象都白色的）</li>
<li>灰色：对象本身被扫描（根可达对象），但该对象的子对象未完成扫描；灰色是一个<code>过渡色</code>，最终都会被标记为<code>黑色</code>。</li>
<li>黑色：根对象或者该对象与它的子对象均被扫描（存活的对象，不会被清理）</li>
</ul>
<h2 id="三色标记的步骤">三色标记的步骤</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403272045933.JPG" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403272046857.JPG" /></p>
<h1 id="如何回收垃圾垃圾收集算法">如何回收垃圾（垃圾收集算法）</h1>
<h2 id="标记-清除算法">标记-清除算法</h2>
<p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有需要回收的对象（用可达性算法），在标记完成后统一回收掉这些对象。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261010174.png"
alt="算法演示" />
<figcaption aria-hidden="true">算法演示</figcaption>
</figure>
<p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ol type="1">
<li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li>
<li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li>
</ol>
<h2 id="复制算法">复制算法</h2>
<p>复制算法（Copying）是在标记清除算法上演化而来的，用于解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</p>
<p>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样就保证了内存的连续性，逻辑清晰，运行高效。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261011679.png"
alt="算法演示" />
<figcaption aria-hidden="true">算法演示</figcaption>
</figure>
<p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p>
<ul>
<li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li>
<li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li>
</ul>
<h2 id="标记-整理算法">标记-整理算法</h2>
<p>标记整理算法（Mark-Compact），标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261227494.png"
alt="算法演示" />
<figcaption aria-hidden="true">算法演示</figcaption>
</figure>
<p>标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法差很多。</p>
<h2 id="分代收集算法">分代收集算法</h2>
<p>当前虚拟机的垃圾收集都采用分代收集算法，分代收集算法（Generational
Collection）严格来说并不是一种思想或理论，而是融合上述 3
种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。</p>
<p>根据对象存活周期的不同会将内存划分为几块，一般是把 Java
堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261230609.png"
alt="新生代和老年代" />
<figcaption aria-hidden="true">新生代和老年代</figcaption>
</figure>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收。</p>
<h1 id="新生代和老年代">新生代和老年代</h1>
<p>堆（Heap）是 JVM
中最大的一块内存区域，也是垃圾收集器管理的主要区域。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261235085.png"
alt="新生代和老年代" />
<figcaption aria-hidden="true">新生代和老年代</figcaption>
</figure>
<p>堆主要分为 2 个区域，年轻代与老年代，其中年轻代又分 Eden 区和
Survivor 区，其中 Survivor 区又分 From 和 To 两个区。</p>
<h2 id="eden区">Eden区</h2>
<p>据 IBM 公司之前的研究表明，有将近 98%
的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden
区中进行分配，当 Eden 区没有足够空间进行分配时，JVM 会发起一次 Minor
GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。</p>
<p>通过 Minor GC 之后，Eden
区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的
From 区，如果 From 区不够，则直接进入 To 区。、</p>
<p><code>Eden</code>区一般占8份，<code>SurvivorFrom</code>和<code>SurvivorTo</code>一般分别占一份</p>
<h2 id="survivor区">Survivor区</h2>
<p>Survivor 区相当于是 Eden 区和 Old
区的一个缓冲，类似于我们交通灯中的黄灯。</p>
<h3 id="为什么需要survivor区">1、为什么需要Survivor区</h3>
<p>不就是新生代到老年代吗，直接 Eden 到 Old
不好了吗，为啥要这么复杂。</p>
<p>如果没有 Survivor 区，Eden 区每进行一次 Minor
GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次
Minor GC
没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。</p>
<p>这时候移入老年区，很明显不是一个明智的决定。</p>
<p>所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major
GC 的发生。Survivor 的预筛选保证，只有经历 16 次 Minor GC
还能在新生代中存活的对象，才会被送到老年代。</p>
<h3 id="survivor-区为啥划分为两块">2、Survivor 区为啥划分为两块？</h3>
<p>设置两个 Survivor
区最大的好处就是解决内存碎片化，我们先假设一下，Survivor
只有一个区域会怎样。</p>
<p>Minor GC 执行后，Eden 区被清空，存活的对象放到了 Survivor 区，而之前
Survivor
区中的对象，可能也有一些是需要被清除的。那么问题来了，这时候我们怎么清除它们？</p>
<p>在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。</p>
<p>但因为 Survivor 有 2 个区域，所以每次 Minor GC，会将之前 Eden 区和
From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To
职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From
区域，以此反复。</p>
<p>这种机制最大的好处就是，整个过程中，永远有一个 Survivor space
是空的，另一个非空的 Survivor space 是无碎片的。</p>
<p>那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个？</p>
<p>显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致
Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。</p>
<h2 id="old区">Old区</h2>
<p>老年代占据着 2/3 的堆内存空间，只有在 Major GC
的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW
的时间也越长，所以内存也不仅仅是越大就越好。</p>
<p>由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记整理算法。</p>
<p>除了上述所说，在内存担保机制下，无法安置的对象会直接进到老年代，以下几种情况也会进入老年代。</p>
<h3 id="大对象">1、大对象</h3>
<p>大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在
Eden 区及 2 个 Survivor
区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。</p>
<h3 id="长期存活对象">2、长期存活对象</h3>
<p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在
<code>Survivor</code> 的 <code>From</code> 区与 <code>To</code>
区之间移动，对象在 <code>Survivor</code> 区中每经历一次
<code>Minor GC</code>，年龄就增加 1 岁。当年龄增加到 15
岁时，这时候就会被转移到老年代。当然，这里的 15，JVM 也支持进行特殊设置
<code>-XX:MaxTenuringThreshold=10</code>。</p>
<p>可通过
<code>java -XX:+PrintFlagsFinal -version | grep MaxTenuringThreshold</code>
查看默认的阈值。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261332145.png" /></p>
<h3 id="动态对象年龄">3、动态对象年龄</h3>
<p>JVM 并不强制要求对象年龄必须到 15 岁才会放入老年区，如果 Survivor
空间中某个年龄段的对象总大小超过了 Survivor
空间的一半，那么该年龄段及以上年龄段的所有对象都会在下一次垃圾回收时被晋升到老年代，无需等你“成年”。</p>
<p>有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机器的硬件不同，健康状况不同，所以我们可以基于每台机器接收的请求数、响应时间等，来调整负载均衡算法。</p>
<p>这种动态调整机制有助于优化内存使用和减少垃圾收集的频率，特别是在处理大量短生命周期对象的应用程序时。</p>
<h1 id="垃圾收集器">垃圾收集器</h1>
<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>
<p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的
HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p>
<p>JDK 默认垃圾收集器（使用
<code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p>
<ul>
<li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li>
<li>JDK 9 ~ JDK20: G1</li>
</ul>
<p>关于一些老的收集器直接去看JavaGuide中的介绍：<a
href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html#parallel-scavenge-%E6%94%B6%E9%9B%86%E5%99%A8">收集器</a></p>
<h2 id="分代收集器">分代收集器</h2>
<h3 id="cms">CMS</h3>
<p>以获取最短回收停顿时间为目标，采用“标记-清除”算法，分 4
大步进行垃圾收集，其中初始标记和重新标记会 STW，JDK 1.5 时引入，JDK9
被标记弃用，JDK14 被移除，详情可见 <a
href="https://openjdk.java.net/jeps/363">JEP 363open in new
window</a>。</p>
<p><strong>CMS（Concurrent Mark Sweep）垃圾收集器是第一个关注 GC
停顿时间（STW
的时间）的垃圾收集器</strong>。之前的垃圾收集器，要么是串行的垃圾回收方式，要么只关注系统吞吐量。</p>
<p>CMS 垃圾收集器之所以能够实现对 GC
停顿时间的控制，其本质来源于对「可达性分析算法」的改进，即三色标记算法。在
CMS 出现之前，无论是 Serious 垃圾收集器，还是 ParNew 垃圾收集器，以及
Parallel Scavenge 垃圾收集器，它们在进行垃圾回收的时候都需要 Stop the
World，无法实现垃圾回收线程与用户线程的并发执行。</p>
<p>CMS
垃圾收集器通过三色标记算法，实现了垃圾回收线程与用户线程的并发执行，从而极大地降低了系统响应时间，提高了强交互应用程序的体验。它的运行过程分为
4 个步骤，包括：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p><strong>初始标记</strong>，指的是寻找所有被 GCRoots
引用的对象，该阶段需要「Stop the World」。这个步骤仅仅只是标记一下 GC
Roots 能直接关联到的对象，并不需要做整个引用的扫描，因此速度很快。</p>
<p><strong>并发标记</strong>，指的是对「初始标记阶段」标记的对象进行整个引用链的扫描，该阶段不需要「Stop
the World」。
对整个引用链做扫描需要花费非常多的时间，因此通过垃圾回收线程与用户线程并发执行，可以降低垃圾回收的时间。</p>
<p>这也是 CMS 能极大降低 GC
停顿时间的核心原因，但这也带来了一些问题，即：并发标记的时候，引用可能发生变化，因此可能发生漏标（本应该回收的垃圾没有被回收）和多标（本不应该回收的垃圾被回收）了。</p>
<p><strong>重新标记</strong>，指的是对「并发标记」阶段出现的问题进行校正，该阶段需要「Stop
the
World」。正如并发标记阶段说到的，由于垃圾回收算法和用户线程并发执行，虽然能降低响应时间，但是会发生漏标和多标的问题。所以对于
CMS 来说，它需要在这个阶段做一些校验，解决并发标记阶段发生的问题。</p>
<p><strong>并发清除</strong>，指的是将标记为垃圾的对象进行清除，该阶段不需要「Stop
the World」。
在这个阶段，垃圾回收线程与用户线程可以并发执行，因此并不影响用户的响应时间。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261345866.png" /></p>
<p>CMS 的优点是：并发收集、低停顿。但缺点也很明显：</p>
<p>1、对 CPU 资源非常敏感，因此在 CPU 资源紧张的情况下，CMS
的性能会大打折扣。</p>
<p>默认情况下，CMS
启用的垃圾回收线程数是<code>（CPU数量 + 3)/4</code>，当 CPU
数量很大时，启用的垃圾回收线程数占比就越小。但如果 CPU
数量很小，例如只有 2 个 CPU，垃圾回收线程占用就达到了
50%，这极大地降低系统的吞吐量，无法接受。</p>
<p>2、CMS
采用的是「标记-清除」算法，会产生大量的内存碎片，导致空间不连续，当出现大对象无法找到连续的内存空间时，就会触发一次
Full GC，这会导致系统的停顿时间变长。</p>
<p>3、CMS 无法处理浮动垃圾，当 CMS
在进行垃圾回收的时候，应用程序还在不断地产生垃圾，这些垃圾会在 CMS
垃圾回收结束之后产生，这些垃圾就是浮动垃圾，CMS
无法处理这些浮动垃圾，只能在下一次 GC 时清理掉。</p>
<p>4、可能出现并发模式失败。CMS的目标就是在回收老年代对象时与用户线程并发运行，如果垃圾回收时应用线程向老年代请求分配的空间超过预留空间，就会抛出"<code>concurrent mode failure</code>"（并发模式失败），此时CMS会暂停用户线程的执行，启用
<code>Serial Old</code> 收集器来重新进行老年代的垃圾收集。</p>
<h2 id="分区收集器">分区收集器</h2>
<h3 id="g1">G1</h3>
<p>G1（Garbage-First Garbage Collector）在 JDK 1.7 时引入，在 JDK 9
时取代 CMS 成为了默认的垃圾收集器。G1
有五个属性：分代、增量、并行、标记整理、STW。</p>
<p>①、分代：上一讲中的年轻代和老年代，G1
也是基于这个思想进行设计的。它将堆内存分为多个大小相等的区域（Region），每个区域都可以是
Eden 区、Survivor 区或者 Old 区。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261354107.png" /></p>
<p>可以通过 <code>-XX:G1HeapRegionSize=n</code> 来设置 Region
的大小，可以设定为 1M、2M、4M、8M、16M、32M（不能超过）。</p>
<p>G1 有专门分配大对象的 Region 叫 Humongous
区，而不是让大对象直接进入老年代的 Region 中。在 G1
中，大对象的判定规则就是一个大对象超过了一个 Region 大小的 50%，比如每个
Region 是 2M，只要一个对象超过了 1M，就会被放入 Humongous
中，而且一个大对象如果太大，可能会横跨多个 Region 来存放。</p>
<p>G1
会根据各个区域的垃圾回收情况来决定下一次垃圾回收的区域，这样就避免了对整个堆内存进行垃圾回收，从而降低了垃圾回收的时间。</p>
<p>②、增量：G1
可以以增量方式执行垃圾回收，这意味着它不需要一次性回收整个堆空间，而是可以逐步、增量地清理。有助于控制停顿时间，尤其是在处理大型堆时。</p>
<p>③、并行：G1 垃圾回收器可以并行回收垃圾，这意味着它可以利用多个 CPU
来加速垃圾回收的速度，这一特性在年轻代的垃圾回收（Minor
GC）中特别明显，因为年轻代的回收通常涉及较多的对象和较高的回收速率。</p>
<p>④、标记整理：在进行老年代的垃圾回收时，G1
使用标记-整理算法。这个过程分为两个阶段：标记存活的对象和整理（压缩）堆空间。通过整理，G1
能够避免内存碎片化，提高内存利用率。</p>
<p>年轻代的垃圾回收（Minor
GC）使用复制算法，因为年轻代的对象通常是朝生夕死的。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261355917.png" /></p>
<p>⑤、STW：G1
也是基于「标记-清除」算法，因此在进行垃圾回收的时候，仍然需要「Stop the
World」。不过，G1
在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261355182.png" /></p>
<p>G1 中存在三种 GC 模式，分别是 Young GC、Mixed GC 和 Full GC。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403261355479.png" /></p>
<p>当 Eden 区的内存空间无法支持新对象的内存分配时，G1 会触发 Young
GC。</p>
<p>当需要分配对象到 Humongous 区域或者堆内存的空间占比超过
<code>-XX:G1HeapWastePercent</code> 设置的
InitiatingHeapOccupancyPercent 值时，G1 会触发一次 concurrent
marking，它的作用就是计算老年代中有多少空间需要被回收，当发现垃圾的占比达到
<code>-XX:G1HeapWastePercent</code> 中所设置的 G1HeapWastePercent
比例时，在下次 Young GC 后会触发一次 Mixed GC。</p>
<p>Mixed GC 是指回收年轻代的 Region 以及一部分老年代中的 Region。Mixed
GC 和 Young GC 一样，采用的也是复制算法。</p>
<p>在 Mixed GC 过程中，如果发现老年代空间还是不足，此时如果
G1HeapWastePercent 设定过低，可能引发 Full
GC。<code>-XX:G1HeapWastePercent</code> 默认是 5，意味着只有 5%
的堆是“浪费”的。如果浪费的堆的百分比大于 G1HeapWastePercent，则运行 Full
GC。</p>
<p>在以 Region 为最小管理单元以及所采用的 GC 模式的基础上，G1
建立了停顿预测模型，即 Pause Prediction Model 。这也是 G1
非常被人所称道的特性。</p>
<p>我们可以借助 <code>-XX:MaxGCPauseMillis</code>
来设置期望的停顿时间（默认 200ms），G1 会根据这个值来计算出一个合理的
Young GC 的回收时间，然后根据这个时间来制定 Young GC 的回收计划。</p>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<h3 id="zgc">ZGC</h3>
<p>ZGC（The Z Garbage Collector）是 JDK11
推出的一款低延迟垃圾收集器，适用于大内存低延迟服务的内存管理和回收，SPEC
jbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68
ms，停顿时间远胜于 G1 和 CMS。</p>
<p>ZGC 的设计目标是：</p>
<ul>
<li>停顿时间不超过 10ms；</li>
<li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li>
<li>支持 8MB~4TB 级别的堆，未来支持 16TB。</li>
</ul>
<p>与 G1 和 CMS 类似，ZGC 也采用了复制算法，只不过做了重大优化，ZGC
在标记、转移和重定位阶段几乎都是并发的，这是 ZGC 实现停顿时间小于 10ms
的关键所在。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403271557685.png" /></p>
<p>ZGC 是怎么做到的呢？</p>
<ul>
<li>指针染色（Colored Pointer）：一种用于标记对象状态的技术。</li>
<li>读屏障（Load
Barrier）：一种在程序运行时插入到对象访问操作中的特殊检查，用于确保对象访问的正确性。</li>
</ul>
<p>这两种技术可以让所有线程在并发的条件下就指针的颜色 (状态)
达成一致，而不是对象地址。因此，ZGC 可以并发的复制对象，这大大的降低了
GC 的停顿时间。</p>
<h4 id="指针染色">指针染色</h4>
<p>在一个指针中，除了存储对象的实际地址外，还有额外的位被用来存储关于该对象的元数据信息。这些信息可能包括：</p>
<ul>
<li>对象是否被移动了（即它是否在回收过程中被移动到了新的位置）。</li>
<li>对象的存活状态。</li>
<li>对象是否被锁定或有其他特殊状态。</li>
</ul>
<p>通过在指针中嵌入这些信息，ZGC
在标记和转移阶段会更快，因为通过指针上的颜色就能区分出对象状态，不用额外做内存访问。</p>
<p>ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间，如下图所示：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403271557105.png" /></p>
<p>其中，0-4TB 对应 Java 堆，4TB-8TB 被称为 M0 地址空间，8TB-12TB 被称为
M1 地址空间，12TB-16TB 预留未使用，16TB-20TB 被称为 Remapped 空间。</p>
<p>当创建对象时，首先在堆空间申请一个虚拟地址，该虚拟地址并不会映射到真正的物理地址。同时，ZGC
会在 M0、M1、Remapped
空间中为该对象分别申请一个虚拟地址，且三个虚拟地址都映射到同一个物理地址。</p>
<p>下图是虚拟地址的空间划分：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403271557827.png" /></p>
<p>不过，三个空间在同一时间只有一个空间有效。ZGC
之所以设置这三个虚拟地址，是因为 ZGC 采用的是“空间换时间”的思想，去降低
GC 的停顿时间。</p>
<p>与上述地址空间划分相对应，ZGC实际仅使用64位地址空间的第0-41位，而第42-45位存储元数据，第47-63位固定为0。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403271557352.png" /></p>
<p>由于仅用了第 0~43 位存储对象地址，244 = 16TB，所以 ZGC 最大支持 16TB
的堆。</p>
<p>至于对象的存活信息，则存储在42-45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。</p>
<h4 id="读屏障">读屏障</h4>
<p>当程序尝试读取一个对象时，读屏障会触发以下操作：</p>
<ul>
<li>检查指针染色：读屏障首先检查指向对象的指针的颜色信息。</li>
<li>处理移动的对象：如果指针表示对象已经被移动（例如，在垃圾回收过程中），读屏障将确保返回对象的新位置。</li>
<li>确保一致性：通过这种方式，ZGC
能够在并发移动对象时保持内存访问的一致性，从而减少对应用程序停顿的需要。</li>
</ul>
<p>ZGC读屏障如何实现呢？</p>
<p>来看下面这段伪代码，涉及 JVM 的底层 C++ 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码示例，展示读屏障的概念性实现</span></span><br><span class="line"><span class="function">Object* <span class="title">read_barrier</span><span class="params">(Object* ref)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_forwarded</span>(ref)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_forwarded_address</span>(ref); <span class="comment">// 获取对象的新地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref; <span class="comment">// 对象未移动，返回原始引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>read_barrier 代表读屏障。</li>
<li>如果对象已被移动（is_forwarded(ref)），方法返回对象的新地址（get_forwarded_address(ref)）。</li>
<li>如果对象未被移动，方法返回原始的对象引用。</li>
</ul>
<p>读屏障可能被GC线程和业务线程触发，并且只会在访问堆内对象时触发，访问的对象位于GC
Roots时不会触发，这也是扫描GC Roots时需要STW的原因。</p>
<p>下面是一个简化的示例代码，展示了读屏障的触发时机。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Object o = obj.FieldA   <span class="comment">// 从堆中读取引用，需要加入屏障</span></span><br><span class="line">&lt;Load barrier&gt;</span><br><span class="line">Object p = o  <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line">o.<span class="built_in">dosomething</span>() <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line"><span class="type">int</span> i =  obj.FieldB  <span class="comment">//无需加入屏障，因为不是对象引用</span></span><br></pre></td></tr></table></figure>
<h4 id="zgc-的工作过程">ZGC 的工作过程</h4>
<p>ZGC 周期由三个 STW 暂停和四个并发阶段组成：标记/重新映射( M/R
)、并发引用处理( RP )、并发转移准备( EC ) 和并发转移( RE )。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403271600752.png" /></p>
<h5 id="stop-the-world-暂停阶段">Stop-The-World 暂停阶段</h5>
<ol type="1">
<li><strong>标记开始（Mark Start）STW 暂停</strong>：这是 ZGC
的开始，进行 GC Roots 的初始标记。在这个短暂的停顿期间，ZGC 标记所有从
GC Root 直接可达的对象。</li>
<li><strong>重新映射开始（Relocation Start）STW
暂停</strong>：在并发阶段之后，这个 STW
暂停是为了准备对象的重定位。在这个阶段，ZGC
选择将要清理的内存区域，并建立必要的数据结构以进行对象移动。</li>
<li><strong>暂停结束（Pause End）STW 暂停</strong>：ZGC
结束。在这个短暂的停顿中，完成所有与该 GC 周期相关的最终清理工作。</li>
</ol>
<h5 id="并发阶段">并发阶段</h5>
<ol type="1">
<li><strong>并发标记/重新映射 (M/R)</strong>
：这个阶段包括并发标记和并发重新映射。在并发标记中，ZGC
遍历对象图，标记所有可达的对象。然后，在并发重新映射中，ZGC
更新指向移动对象的所有引用。</li>
<li><strong>并发引用处理 (RP)</strong> ：在这个阶段，ZGC
处理各种引用类型（如软引用、弱引用、虚引用和幽灵引用）。这些引用的处理通常需要特殊的考虑，因为它们与对象的可达性和生命周期密切相关。</li>
<li><strong>并发转移准备 (EC)</strong> ：这是为对象转移做准备的阶段。ZGC
确定哪些内存区域将被清理，并准备相关的数据结构。</li>
<li><strong>并发转移 (RE)</strong> ：在这个阶段，ZGC
将存活的对象从旧位置移动到新位置。由于这一过程是并发执行的，因此应用程序可以在大多数垃圾回收工作进行时继续运行。</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403271600601.png" /></p>
<p>ZGC
的两个关键技术：指针染色和读屏障，不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在ZGC中，只需要设置指针地址的第42-45位即可，并且因为是寄存器访问，所以速度比访问内存更快。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403271600269.png" /></p>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器</title>
    <url>/2024/03/28/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>类加载器详解</p>
</blockquote>
<span id="more"></span>
<h1 id="类加载过程">类加载过程</h1>
<p>开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。</p>
<ul>
<li>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。</li>
<li>连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403281154026.png"
alt="类加载过程" />
<figcaption aria-hidden="true">类加载过程</figcaption>
</figure>
<p>加载是类加载过程的第一步，主要完成下面 3 件事情：</p>
<ol type="1">
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 <code>Class</code>
对象，作为方法区这些数据的访问入口</li>
</ol>
<h1 id="类加载器">类加载器</h1>
<h2 id="类加载器介绍">类加载器介绍</h2>
<p>类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java
Applet（已经被淘汰） 的需要。后来，慢慢成为 Java
程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM
中并执行的能力。</p>
<blockquote>
<p>类加载器是一个负责加载类的对象。<code>ClassLoader</code>
是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。</p>
<p>每个 Java 类都有一个引用指向加载它的
<code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code>
创建的，而是 JVM
在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取
<code>ClassLoader</code> 的时候和该数组的元素类型的
<code>ClassLoader</code> 是一致的。</p>
</blockquote>
<p>从上面的介绍可以看出:</p>
<ul>
<li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</li>
<li>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</li>
<li>数组类不是通过 <code>ClassLoader</code>
创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，<strong>类加载器的主要作用就是加载 Java 类的字节码（
<code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的
<code>Class</code> 对象）。</strong> 字节码可以是 Java
源程序（<code>.java</code>文件）经过 <code>javac</code>
编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p>
<p>其实除了加载类之外，类加载器还可以加载 Java
应用所需的资源如文本、图像、配置文件、视频等等文件资源。本文只讨论其核心功能：加载类。</p>
<h2 id="类加载器规则">类加载器规则</h2>
<p>JVM
启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</p>
<p>对于已经加载的类会被放在 <code>ClassLoader</code>
中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类加载器总结">类加载器总结</h2>
<p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p>
<ol type="1">
<li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由
C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK
内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的
<code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等
jar 包和类）以及被
<code>-Xbootclasspath</code>参数指定的路径下的所有类。</li>
<li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载
<code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被
<code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li>
<li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向我们用户的加载器，负责加载当前应用
classpath 下的所有 jar 包和类。</li>
</ol>
<blockquote>
<p><strong><code>rt.jar</code></strong>：rt
代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc
里面看到的所有的类的类文件。也就是说，我们常用内置库
<code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</p>
<p>Java 9
引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform
class loader）。Java SE 中除了少数几个关键模块，比如说
<code>java.base</code>
是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</p>
</blockquote>
<p>除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对
Java 类的字节码（ <code>.class</code>
文件）进行加密，加载时再利用自定义的类加载器对其解密。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403281158378.png"
alt="类加载器层次关系图" />
<figcaption aria-hidden="true">类加载器层次关系图</figcaption>
</figure>
<p>除了 <code>BootstrapClassLoader</code> 是 JVM
自身的一部分之外，其他所有的类加载器都是在 JVM
外部实现的，并且全都继承自
<code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p>
<p>每个 <code>ClassLoader</code>
可以通过<code>getParent()</code>获取其父
<code>ClassLoader</code>，如果获取到 <code>ClassLoader</code>
为<code>null</code>的话，那么该类是通过
<code>BootstrapClassLoader</code> 加载的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 父加载器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么 获取到 <code>ClassLoader</code>
为<code>null</code>就是 <code>BootstrapClassLoader</code>
加载的呢？</strong> 这是因为<code>BootstrapClassLoader</code> 由 C++
实现，由于这个 C++ 实现的类加载器在 Java
中是没有与之对应的类的，所以拿到的结果是 null。</p>
<p>下面我们来看一个获取 <code>ClassLoader</code> 的小案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintClassLoaderTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> PrintClassLoaderTree.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">split</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;|--&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needContinue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (needContinue)&#123;</span><br><span class="line">            System.out.println(split.toString() + classLoader);</span><br><span class="line">            <span class="keyword">if</span>(classLoader == <span class="literal">null</span>)&#123;</span><br><span class="line">                needContinue = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                classLoader = classLoader.getParent();</span><br><span class="line">                split.insert(<span class="number">0</span>, <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果(JDK 8 )：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">|--sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">    |--sun.misc.Launcher$ExtClassLoader@53bd815b</span><br><span class="line">        |--<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>从输出结果可以看出：</p>
<ul>
<li>我们编写的 Java 类 <code>PrintClassLoaderTree</code> 的
<code>ClassLoader</code> 是<code>AppClassLoader</code>；</li>
<li><code>AppClassLoader</code>的父 <code>ClassLoader</code>
是<code>ExtClassLoader</code>；</li>
<li><code>ExtClassLoader</code>的父<code>ClassLoader</code>是<code>Bootstrap ClassLoader</code>，因此输出结果为
null。</li>
</ul>
<h2 id="自定义类加载器">自定义类加载器</h2>
<p>我们前面也说说了，除了 <code>BootstrapClassLoader</code>
其他类加载器均由 Java
实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承
<code>ClassLoader</code>抽象类。</p>
<p><code>ClassLoader</code> 类有两个关键的方法：</p>
<ul>
<li><p><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制
。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为
true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code>
方法解析该类。</p></li>
<li><p><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</p></li>
</ul>
<p>官方 API 文档中写到：</p>
<blockquote>
<p>Subclasses of <code>ClassLoader</code> are encouraged to override
<code>findClass(String name)</code>, rather than this method.</p>
<p>建议 <code>ClassLoader</code>的子类重写
<code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code>
方法。</p>
</blockquote>
<p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的
<code>findClass()</code>
方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写
<code>loadClass()</code> 方法。</p>
<h1 id="双亲委派模型">双亲委派模型</h1>
<h2 id="双亲委派模型介绍">双亲委派模型介绍</h2>
<p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。</p>
<blockquote>
<p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。每个
<code>ClassLoader</code>
实例都有一个相关的父类加载器。需要查找类或资源时，<code>ClassLoader</code>
实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。
虚拟机中被称为 "bootstrap class
loader"的内置类加载器本身没有父类加载器，但是可以作为
<code>ClassLoader</code> 实例的父类加载器。</p>
</blockquote>
<p>从上面的介绍可以看出：</p>
<ul>
<li><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</li>
<li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li>
<li><code>ClassLoader</code>
实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</li>
</ul>
<p>下图展示的各种类加载器之间的层次关系被称为类加载器的“<strong>双亲委派模型(Parents
Delegation Model)</strong>”。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403281202919.png"
alt="类加载器层次关系图" />
<figcaption aria-hidden="true">类加载器层次关系图</figcaption>
</figure>
<p>注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK
官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p>
<p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个
<code>MotherClassLoader</code> 和一个<code>FatherClassLoader</code>
。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。</p>
<p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承。</strong></p>
<h2 id="双亲委派模型的执行流程">双亲委派模型的执行流程</h2>
<p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在
<code>java.lang.ClassLoader</code> 的 <code>loadClass()</code>
中，相关代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p>
<p>结合上面的源码，简单总结一下双亲委派模型的执行流程：</p>
<ul>
<li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li>
<li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器
<code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器
<code>BootstrapClassLoader</code> 中。</li>
<li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的
<code>findClass()</code> 方法来加载类）。</li>
<li>如果子类加载器也无法加载这个类，那么它会抛出一个
<code>ClassNotFoundException</code> 异常。</li>
</ul>
<blockquote>
<p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM
不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个
<code>Class</code>
文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p>
</blockquote>
<h2 id="双亲委派模型的好处">双亲委派模型的好处</h2>
<p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM
区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了
Java 的核心 API 不被篡改。</p>
<p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为
<code>java.lang.Object</code>
类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code>
类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code>
类，而不是你写的 <code>Object</code> 类。这是因为
<code>AppClassLoader</code> 在加载你的 <code>Object</code>
类时，会委托给 <code>ExtClassLoader</code> 去加载，而
<code>ExtClassLoader</code> 又会委托给
<code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code>
发现自己已经加载过了 <code>Object</code>
类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p>
<h2 id="打破双亲委派模型的方法">打破双亲委派模型的方法</h2>
<p>自定义加载器的话，需要继承 <code>ClassLoader</code>
。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的
<code>findClass()</code>
方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写
<code>loadClass()</code> 方法。</p>
<p>为什么是重写 <code>loadClass()</code>
方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p>
<blockquote>
<p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器
<code>loadClass()</code>方法来加载类）。</p>
</blockquote>
<p>重写
<code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。</p>
<p>我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web
应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器
<code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web
应用之间的类实现隔离的具体原理。</p>
<p>Tomcat 的类加载器的层次结构如下：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/JUSTINAYA/My-ImgHost@main/img/202403281207948.png"
alt="Tomcat 的类加载器的层次结构" />
<figcaption aria-hidden="true">Tomcat 的类加载器的层次结构</figcaption>
</figure>
<p>Tomcat 这四个自定义的类加载器对应的目录如下：</p>
<ul>
<li><code>CommonClassLoader</code>对应<code>&lt;Tomcat&gt;/common/*</code></li>
<li><code>CatalinaClassLoader</code>对应<code>&lt;Tomcat &gt;/server/*</code></li>
<li><code>SharedClassLoader</code>对应
<code>&lt;Tomcat &gt;/shared/*</code></li>
<li><code>WebAppClassloader</code>对应
<code>&lt;Tomcat &gt;/webapps/&lt;app&gt;/WEB-INF/*</code></li>
</ul>
<p>从图中的委派关系中可以看出：</p>
<ul>
<li><p><code>CommonClassLoader</code>作为
<code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code>
的父加载器。<code>CommonClassLoader</code> 能加载的类都可以被
<code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code>
使用。因此，<code>CommonClassLoader</code>
是为了实现公共类库（可以被所有 Web 应用和 Tomcat
内部组件使用的类库）的共享和隔离。</p></li>
<li><p><code>CatalinaClassLoader</code> 和
<code>SharedClassLoader</code>
能加载的类则与对方相互隔离。<code>CatalinaClassLoader</code> 用于加载
Tomcat 自身的类，为了隔离 Tomcat 本身的类和 Web
应用的类。<code>SharedClassLoader</code> 作为
<code>WebAppClassLoader</code> 的父加载器，专门来加载 Web
应用之间共享的类比如 Spring、Mybatis。</p></li>
<li><p>每个 Web 应用都会创建一个单独的
<code>WebAppClassLoader</code>，并在启动 Web
应用的线程里设置线程线程上下文类加载器为
<code>WebAppClassLoader</code>。各个 <code>WebAppClassLoader</code>
实例之间相互隔离，进而实现 Web 应用之间的类隔。</p></li>
</ul>
<p>单纯依靠自定义类加载器没办法满足某些场景的要求，例如，有些情况下，高层的类加载器需要加载低层的加载器才能加载的类。</p>
<p>比如，SPI 中，SPI 的接口（如 <code>java.sql.Driver</code>）是由 Java
核心库提供的，由<code>BootstrapClassLoader</code> 加载。而 SPI
的实现（如<code>com.mysql.cj.jdbc.Driver</code>）是由第三方供应商提供的，它们是由应用程序类加载器或者自定义类加载器来加载的。默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载
SPI 的接口的类加载器（<code>BootstrapClassLoader</code>）也会用来加载
SPI 的实现。按照双亲委派模型，<code>BootstrapClassLoader</code>
是无法找到 SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。</p>
<p>再比如，假设我们的项目中有 Spring 的 jar 包，由于其是 Web
应用之间共享的，因此会由 <code>SharedClassLoader</code> 加载（Web
服务器是 Tomcat）。我们项目中有一些用到了 Spring 的业务类，比如实现了
Spring 提供的接口、用到了 Spring 提供的注解。所以，加载 Spring
的类加载器（也就是
<code>SharedClassLoader</code>）也会用来加载这些业务类。但是业务类在 Web
应用目录下，不在 <code>SharedClassLoader</code> 的加载路径下，所以
<code>SharedClassLoader</code> 无法找到业务类，也就无法加载它们。</p>
<p>如何解决这个问题呢？ 这个时候就需要用到
<strong>线程上下文类加载器（<code>ThreadContextClassLoader</code>）</strong>
了。</p>
<p>拿 Spring 这个例子来说，当 Spring
需要加载业务类的时候，它不是用自己的类加载器，而是用当前线程的上下文类加载器。还记得我上面说的吗？每个
Web 应用都会创建一个单独的 <code>WebAppClassLoader</code>，并在启动 Web
应用的线程里设置线程线程上下文类加载器为
<code>WebAppClassLoader</code>。这样就可以让高层的类加载器（<code>SharedClassLoader</code>）借助子类加载器（
<code>WebAppClassLoader</code>）来加载业务类，破坏了 Java
的类加载委托机制，让应用逆向使用类加载器。</p>
<p>线程线程上下文类加载器的原理是将一个类加载器保存在线程私有数据里，跟线程绑定，然后在需要的时候取出来使用。这个类加载器通常是由应用程序或者容器（如
Tomcat）设置的。</p>
<p><code>Java.lang.Thread</code>
中的<code>getContextClassLoader()</code>和
<code>setContextClassLoader(ClassLoader cl)</code>分别用来获取和设置线程的上下文类加载器。如果没有通过<code>setContextClassLoader(ClassLoader cl)</code>进行设置的话，线程将继承其父线程的上下文类加载器。</p>
<p>Spring 获取线程线程上下文类加载器的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cl = Thread.currentThread().getContextClassLoader();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java八股</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>八股</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
